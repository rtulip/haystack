
// Note: <T> marks that dup is generic over one variable T
// Note: T:value will remove T from the stack and associate it with the identifier `value`.
// Note: [T, T] indicates that two instances of T will be left on the stack after calling `dup<T>` 
// Note: `value` is dropped after returning from dup
fn dup<T>(T: value) -> [T T] {
    value value
}

// Note: you can omit naming a variable, which will not consume it from the stack.
fn add_ints(int int) -> [int] {
    +
}

// Note: mixing named and un-named inputs will not be supported.
// fn doesnt_compile(int int: b) {} // Compiler Error

fn assign_names(int int) -> [int] {
    // Note: You can consume items from the top of the stack to give them a variable name
    name [a b]
    a b +
}

// Note: No return value, no `-> [...]` 
fn update_variable(int: value) {
    // `->` operator will consume the top element of the stack and save it back into the variable.
    value 5 +  -> value
}

fn temporary_variables() {
    // Initialized variables
    var string: "Hello World"
    // These are equivalent
    "Hello World" name [string]
    
    "New Str" -> string. 
}

// Structs will hav members be named.
struct Str {
    int: size
    ptr<u8>: data
}

fn puts(Str) {
    // ..
}

// Should be able to create aliases to types.
type myint: int

fn main() {

    // Note: calling generic functions can be done without annotations.
    "Hello World" dup 
    puts puts
}
