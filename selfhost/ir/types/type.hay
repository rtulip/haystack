
// Predeclare a type name
// Must ensure that Type is defined later.
struct EnumType {
    Str: name
    Arr<Str>: Variants
}

struct PointerType<T> {
    *T: inner
}

struct StructType<T> {
    Str: name
    Arr<*T>: members
    Arr<Str>: idents
}

struct GenericStructBaseType<T> {
    StructType<T>: base
    Arr<*T>: generics 
}

struct GenericStructInstanceType<T> {
    *GenericStructBaseType<T>: base
    StructType<T>: instance
    Arr<*T>: alias_list
}

struct ResolvedStructType<T> {
    *StructType<T>: base
    StructType<T>: instance
}

struct UnionType<T> {
    Str: name
    Arr<*T>: members
    Arr<Str>: idents
}

struct GenericUnionBaseType<T> {
    UnionType<T>: base
    Arr<*T>: generics
}

struct GenericUnionInstanceType<T> {
    *GenericUnionBaseType<T>: base
    UnionType<T>: instance 
    Arr<*T>: alias_list
}

struct ResolvedUnionType<T> {
    *UnionType<T>: base
    UnionType<T>: instance 
}

enum TypeKind {
    U64
    U8
    Bool
    Enum
    Placeholder
    Pointer
    Struct
    GenericStructBase
    GenericStructInstance
    ResolvedStruct
    Union
    GenericUnionBase
    GenericUnionInstance
    ResolvedUnion
}

union TypeValue<T> {
    u64:                          U64
    u8:                           U8
    bool:                         Bool
    EnumType:                     Enum
    Str:                          Placeholder
    PointerType<T>:               Pointer
    StructType<T>:                Struct
    GenericStructBaseType<T>:     GenericStructBase
    GenericStructInstanceType<T>: GenericStructInstanceType
    ResolvedStructType<T>:        ResolvedStruct
    UnionType<T>:                 Union
    GenericUnionBaseType<T>:      GenericUnionBase
    GenericUnionInstanceType<T>:  GenericUnionInstance
    ResolvedUnionType<T>:         ResolvedUnion
}

struct Type {
    TypeValue<Type>: type
    TypeKind: tag
}

fn Type.from_u64(u64) -> [Type] {
    cast(TypeValue<Type>) TypeKind::U64 cast(Type)  
}

fn Type.from_u8(u8) -> [Type] {
    cast(TypeValue<Type>) TypeKind::U8 cast(Type)
}

fn Type.from_bool(bool) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Bool cast(Type)
}

fn Type.from_enum(EnumType) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Enum cast(Type)
}

fn Type.from_placeholder(Str) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Placeholder cast(Type)
}

fn Type.from_pointer(PointerType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Pointer cast(Type)
}

fn Type.from_struct(StructType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Struct cast(Type)
}

fn Type.from_generic_stuct_base(GenericStructInstanceType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::GenericStructBase cast(Type)
}

fn Type.from_generic_struct_instance(GenericStructInstanceType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::GenericStructInstance cast(Type)
}

fn Type.from_resolved_struct(ResolvedStructType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::ResolvedStruct cast(Type)
}

fn Type.from_union(UnionType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::Union cast(Type)
}

fn Type.from_generic_union_base(GenericUnionBaseType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::GenericUnionBase cast(Type)
}

fn Type.from_generic_union_instance(GenericUnionInstanceType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::GenericUnionInstance cast(Type)
}

fn Type.from_resolved_union(ResolvedUnionType<Type>) -> [Type] {
    cast(TypeValue<Type>) TypeKind::ResolvedUnion cast(Type)
}

//fn main() {
//
//}