enum struct Option<T> {
    []: None
    T : Some
impl:

    inline fn Option.Some<T>(T) -> [Option<T>] { cast(Option::Some) }
    inline fn Option.None<T>() -> [Option<T>] { [] cast(Option::None) }
    inline fn Option.is_some<T>(&Option<T>) -> [bool] {
        @ match {
            Option::Some { true }
            Option::None { false }
        }
    }
    inline fn Option.is_none<T>(&Option<T>) -> [bool] {
        Option.is_some lnot
    }

    inline fn Option.take_is_some<T>(Option<T>: option) -> [bool] {
        &option Option.is_some
    }

    inline fn Option.unwrap<T>(Option<T>) -> [T] {
        match {
            Option::Some as [t] { t }
            Option::None { 
                "Unwrapped a None variant" println 
                1 exit
            }
        }
    }

    fn Option.unwrap_or<T>(T: default Option<T>: option) -> [T] {
        option match {
            Option::Some as [t] { t }
            Option::None { default }
        }
    }

}