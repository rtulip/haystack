include "std/assert.hay"
struct Vec<T> {
    Arr<T>: slice
    u64: len
impl:
    
    inline fn Vec.new<T>() -> [Vec<T>] {
        8 malloc::<T> 0 cast(Vec) 
    }

    inline fn Vec.with_capacity<T>(u64) -> [Vec<T>] {
        malloc::<T> 0 cast(Vec)
    }

    inline fn Vec.delete<T>(&Vec<T>: self) {
        self::slice @ free
    }

    inline fn Vec.is_empty<T>(&Vec<T>: self) -> [bool] {
        self::len @ 0 ==
    }

    inline fn Vec.slice_mut<T>(*Vec<T>: self) -> [Arr<T>] {
        self::slice @
    }

    inline fn Vec.slice<T>(&Vec<T>: self) -> [ConstArr<T>] {
        self::slice::size @
        self::slice::data @
        cast(ConstArr)
    }

    fn Vec.push<T>(T: value *Vec<T>: self) {
        self::len @ 0 == if {
            2 self::slice @ realloc self::slice ! 
        } else self::len @ self::slice::size @ == if {
            self::slice::size @ 2 * self::slice @ realloc self::slice !
        }
        value self::len @ self::slice @ Arr.set
        self::len @ 1 + self::len !
    }

    fn Vec.pop<T>(*Vec<T>: self) -> [Opt<T>] {
        self::len @ 0 == if {
            Opt.None::<T>
        } else {
            self::len @ 1 - self::len !
            self::len @ self::slice @ Arr.at Opt.Some
        }
    }

    fn Vec.get<T>(u64: idx &Vec<T>: self) -> [Opt<&T>] {
        idx self::len @ >= if {
            Opt.None::<&T>
        } else {
            idx self::slice @ Arr.get_ref Opt.Some
        }
    }

    fn Vec.get_mut<T>(u64: idx *Vec<T>: self) -> [Opt<*T>] {
        idx self::len @ >= if {
            Opt.None::<*T>
        } else {
            idx self::slice @ Arr.get_ref_mut Opt.Some
        }
    }

    fn Vec.at<T>(u64: idx &Vec<T>: self) -> [Opt<T>] {
        idx self::len @ >= if {
            Opt.None::<T>
        } else {
            idx self::slice @ Arr.at Opt.Some
        }
    }

    fn Vec.set<T>(u64: idx T: value *Vec<T>: self) {
        idx self Vec.get_mut as [maybe_value]
        &maybe_value Opt.is_some if {
            value maybe_value Opt.unwrap !
        }
    } 

    inline fn Vec.last<T>(&Vec<T>: self) -> [Opt<&T>] {
        self::len @ 1- self Vec.get
    }

    fn Vec.capacity<T>(&Vec<T>: self) -> [u64] {
        self::slice::size @
    }

    fn Vec.len<T>(&Vec<T>: self) -> [u64] {
        self::len @
    }

    fn Vec.contains<T>(T: item &Vec<T>: self) -> [bool] {

        0 while dup self Vec.len < {
            as [i]
            i self Vec.at Opt.unwrap item == if {
                true return
            }
            i 1 +
        } drop

        false

    }

    fn Vec.append<T>(*Vec<T>: other *Vec<T>: self) {
        Vec.new::<T> as [mut temp]

        while other Vec.is_empty lnot {
            other Vec.pop Opt.unwrap *temp Vec.push
        }

        while &temp Vec.is_empty lnot {
            *temp Vec.pop Opt.unwrap self Vec.push
        }

        &temp Vec.delete

    }

    fn Vec.reverse<T>(Vec<T>: mut self) -> [Vec<T>] {

        Vec.new::<T> as [mut rev]
        while &self Vec.is_empty lnot {
            *self Vec.pop Opt.unwrap *rev Vec.push
        }

        &self Vec.delete
        rev
    }

    fn Vec.subslice<T>(u64: start u64: end &Vec<T>: self) -> [Vec<T>] {

        end start < if {
            "Cannot take subslice of Vec where start < end" println
            "Start: " print start println
            "End:   " print end println
            1 exit
        }

        start self Vec.len >= if {
            self Vec.len 1 - 
        } else {
            start
        } as [start_bounded]

        end self Vec.len >= if {
            self Vec.len 1 - 
        } else {
            end
        } as [end_bounded]

        end start -
        self::slice::data @ start ptr+ cast(u64) cast(*T)
        cast(Arr)
        end start -
        cast(Vec)
    }

    fn Vec.bubble_sort<T>(Vec<T>: mut self) -> [Vec<T>] {

        0 while dup &self Vec.len 1 - < { as [i]
            i while dup &self Vec.len 1 - < { as [j]

                j     &self Vec.at Opt.unwrap
                j 1 + &self Vec.at Opt.unwrap as [l r]
                l r > if {
                    j     r *self Vec.set
                    j 1 + l *self Vec.set
                }

                j 1 +
            } drop
            i 1 +
        } drop

        self
    }

}

impl<T> Format<&Vec<T>>
requires: [Format<T>] {

    fn fmt(String &Vec<T>) -> [String] {
        as [self]
        self Vec.len 0 == if { "[ ]" fmt return }
        
        '[' fmt
        0 while dup self Vec.len 1 - < {
            as [i]
            i self Vec.get Opt.unwrap @ fmt
            ' '              fmt
            i 1 +
        } drop

        self Vec.last Opt.unwrap @ fmt 
        ']' fmt
    }

}

impl<T> Format<Vec<T>>
requires: [Format<T>] {
    fn fmt(String Vec<T>) -> [String] {
        as [self]
        &self fmt
        &self Vec.delete
    }
}