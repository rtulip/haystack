struct Vec<T> {
    Arr<T>: heap_slice
    u64: len
}

fn Vec.new<T>(*Vec<T>: vec_p) {
    1 malloc::<T> 0 cast(Vec) vec_p ! 
}

fn Vec.push<T>(T: item *Vec<T>: self_p) {

    self_p @ as [self] {
        self::len self::heap_slice::size == if {
            "Resizing. New size: " puts sizeOf(T) self::heap_slice::size 2 * * putlnu
            self::heap_slice::size 2 * self::heap_slice realloc self::len cast(Vec) self_p !
        }
    }
    
    self_p @ as [self] {
        item self::len self::heap_slice Arr.set
        self::heap_slice self::len 1 + cast(Vec) self_p !
    }

}

fn Vec.destroy<T>(*Vec<T>: self_p) {

    self_p @ as [self] 
    self::heap_slice free

}

fn main() {

    var Vec<u64>: vec
    var Vec<Str>: str_vec
    vec Vec.new
    str_vec Vec.new

    0 while dup 2048 < {
        as [i]
        i vec Vec.push
        i 1 + 
    } drop

    0 while dup 5000 < {
        as [i]
        "Hello World!" str_vec Vec.push
        i 1 +
    } drop

    Heap.debug_summary
    vec Vec.destroy
    str_vec Vec.destroy
    Heap.debug_summary

}