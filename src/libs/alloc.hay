include "arr.hay"
include "stack.hay"
include "opt.hay"
include "sys_x86_64.hay"

struct Block {
    Arr<u8>: arr
    bool: allocated
}

struct Chunk {
    u64: cap
    *Block: start
}

// [(N ptr bool)[ .. data ..  ](N ptr bool)[ .. data .. ] ... ]
//      |-------^                  |-------^
fn Chunk.try_alloc(u64: n *Chunk: chunk_p) -> [Opt<Arr<u8>>] {
    
    chunk_p @ as [chunk]
    chunk::start cast(u64) cast(*u8) chunk::cap ptr+ cast(u64) cast(*Block) as [end]

    Opt.None::<Arr<u8>> chunk::start while as [maybe_alloc ptr] { maybe_alloc ptr
        maybe_alloc Opt.is_none 
        ptr cast(u64) end cast(u64) < land
    }
    {
        as [block_p] drop
        block_p cast(u64) cast(*u8) as [void_block_p]
        block_p @ as [block] 
        
        block::allocated if {
            Opt.None::<Arr<u8>>
            void_block_p sizeOf(Block) ptr+ block::arr::size ptr+ cast(u64) cast(*Block)
        } else {

            block::arr::size n < if {
                Opt.None::<Arr<u8>>
            } else {

                // check to see if there's space for another block:
                n block::arr::size - sizeOf(Block) >= if {
                    // Update the block.
                    n block::arr::data cast(Arr) as [arr]
                    arr true cast(Block) block_p !
                    
                    // Create a new un-allocated block
                    n sizeOf(Block) - block::arr::size - 
                    void_block_p n ptr+ sizeOf(Block) ptr+
                    cast(Arr) false cast(Block)
                    void_block_p sizeOf(Block) ptr+ n ptr+ cast(u64) cast(*Block) !

                    // create the return result
                    arr Opt.Some

                    
                } else {
                    block::arr true cast(Block) block_p !
                    block::arr Opt.Some
                }

            }

            void_block_p sizeOf(Block) ptr+ block::arr::size ptr+ cast(u64) cast(*Block)
        }

    } drop

}

var Chunk[2048]: chunks_data
var Stack<Chunk>: chunk_stack

fn align(u64: n) -> [u64] {
    n
}

fn mmap_alloc(u64: n) -> [Arr<u8>] {
    
    0           // offset
    0           // fd
    34          // MAP_ANONYMOUS | MAP_PRIVATE
    3           // PROT_READ | PROT_WRITE
    n           // length
    0 cast(*u8) // addr
    sys_mmap

    as [addr]

    addr cast(u64) 0 1 - == if {
        "Error: mmap call failed..." putlns
        1 exit
    }

    n addr cast(Arr)

}

fn malloc(u64: n) -> [Arr<u8>] {

    n 512 >= if {
        n align mmap_alloc
    } else {

        
        chunks_data @ chunk_stack @ as [chunk_start chunks]
        Opt.None::<Arr<u8>> 0 while as [maybe_chunk idx] { maybe_chunk idx
            idx chunks::size <
            maybe_chunk Opt.is_none land
        }
        {
            // clear the previous option and capture the index
            as [idx] drop
            idx chunk_start Arr.get_ref as [chunk_p]

            n chunk_p Chunk.try_alloc
            idx 1 +
        } drop

        as [maybe_alloc]

        maybe_alloc Opt.is_some if {
            maybe_alloc Opt.unwrap
        } else {
            n align mmap_alloc
        }
    }

}

fn main() {

    123 mmap_alloc split cast(u64) cast(*u64) cast(Arr) as [arr]
    
    
    "size: " puts arr::size putlnu
    "data: " puts arr::data cast(u64) putlnu
    
    0 while dup arr::size < {
        as [i]
        "arr[" puts i putu "]: " puts 
        i i arr Arr.set
        i arr Arr.get putlnu
        i 1 + 
    } drop



}