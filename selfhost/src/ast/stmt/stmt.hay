include "result.hay"
include "vec.hay"
include "hstring.hay"
include "linear_map.hay"
include "selfhost/src/error.hay" 
include "selfhost/src/ast/stmt/enum.hay"
include "selfhost/src/ast/stmt/function.hay"
include "selfhost/src/ast/stmt/pre_declaration.hay"
include "selfhost/src/ast/stmt/record.hay"
include "selfhost/src/ast/stmt/var.hay"
include "selfhost/src/lex/scanner.hay"

enum StmtTag {
    Function
    PreDeclaration
    Record
    Enum
    Var
}

union StmtKind {
    FunctionStmt: Function
    PreDeclarationStmt: PreDeclaration
    RecordStmt: Record
    EnumStmt: Enum
    VarStmt: Var
}


struct Stmt {
    StmtKind: kind
    StmtTag: tag

impl:

    fn Stmt.from_file(*Map<HString>: visited &HString: path) -> [Result<Vec<Stmt> HayError>] {
        path HString.as_str visited Map.contains if {
            Vec.new::<Stmt> Result.Ok::<Vec<Stmt> HayError> return 
        }

        path HString.as_str HString.from_file as [source]
        path HString.as_str path HString.clone visited Map.insert drop

        path HString.clone source 
        Scanner.new
        Scanner.scan_tokens as [result] {
            &result Result.is_err if {
                result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return 
            }
        }

        Vec.new::<Stmt> Result.Ok::<Vec<Stmt> HayError>

    }

    fn Stmt.from_file_with_prelude(&HString: input_path) -> [Result<Vec<Stmt> HayError>] {
        Map.new::<HString> 
        "src/libs/prelude.hay" HString.new
        as [mut visited prelude_path]
        
        *visited &prelude_path Stmt.from_file

    }

}

