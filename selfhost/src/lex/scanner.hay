include "hstring.hay"
include "result.hay"
include "vec.hay"
include "char.hay"
include "selfhost/src/error.hay"
include "selfhost/src/lex/keyword.hay"
include "selfhost/src/lex/literal.hay"
include "selfhost/src/lex/loc.hay"
include "selfhost/src/lex/marker.hay"
include "selfhost/src/lex/operator.hay"
include "selfhost/src/lex/token.hay"
include "selfhost/src/lex/token_kind.hay"

struct Scanner {
    HString: file
    HString: source 
    Vec<Token>: tokens
    u64: start
    u64: current
    u64: line
    u64: token_start
    u64: token_end
impl:

    inline fn Scanner.new(HString: file HString: source) -> [Scanner] {
        file
        source
        Vec.new::<Token>
        0
        0
        1
        1
        1
        cast(Scanner)
    }

    fn Scanner.scan_tokens(Scanner: mut self) -> [Result<Vec<Token> HayError>] {

        while &self Scanner.is_at_end lnot {
            self::current *self::start !
            self::token_end *self::token_start !
            *self Scanner.scan_token as [result]
            &result Opt.is_some if {
                result Opt.unwrap Result.Err::<Vec<Token> HayError> return
            }   
        }

        TokenKind.EoF 
        "" HString.new
        &self::file HString.clone
        self::line
        self::token_start
        self::token_end
        Token.new
        *self::tokens Vec.push

        self::tokens Result.Ok::<Vec<Token> HayError>

    }

    fn Scanner.scan_token(*Scanner: self) -> [Opt<HayError>] {
        self Scanner.advance as [c]
        '(' c == if {
            Marker::LeftParen TokenKind.Marker self Scanner.add_token
        } else ')' c == if {
            Marker::RightParen TokenKind.Marker self Scanner.add_token
        } else '{' c == if {
            Marker::LeftBrace TokenKind.Marker self Scanner.add_token
        } else '}' c == if {
            Marker::RightBrace TokenKind.Marker self Scanner.add_token
        } else '[' c == if {
            Marker::LeftBracket TokenKind.Marker self Scanner.add_token
        } else ']' c == if {
            Marker::RightBracket TokenKind.Marker self Scanner.add_token
        } else ':' c == if {
            ':' self Scanner.matches if {
                Marker::DoubleColon TokenKind.Marker self Scanner.add_token
            } else {
                Marker::Colon TokenKind.Marker self Scanner.add_token
            }
        } else '+' c == if {
            0 self Scanner.peek char.is_alphabetic if {
                self Scanner.identifier as [result] 
                &result Opt.is_some if {
                    result return
                } 
            } else {
                Operator.Plus TokenKind.Operator self Scanner.add_token
            }
        } else {
            "Unhadled Char: `" puts c putc "`" putlns
            1 exit  
        }

        Opt.None::<HayError>
    }

    fn Scanner.add_token(TokenKind: kind *Scanner: self) {
        kind
        self::source HString.as_str as [mut src_str]{
            self::current @ self::start @ -
            src_str::data self::start @ ptr+
            cast(Str)
            HString.new
        }
        self::file HString.clone
        self::line @
        self::token_start @
        self::token_end @
        Token.new
        self::tokens Vec.push
    }

    inline fn Scanner.is_at_end(&Scanner: self) -> [bool] {
        self::current @ self::source HString.size >= 
    }

    inline fn Scanner.advance(*Scanner: self) -> [char] {
        self::current @ self::source HString.at Opt.unwrap
        self::current   @ 1 + self::current !
        self::token_end @ 1 + self::current !
    }

    fn Scanner.matches(char: expected *Scanner: self) -> [bool] {
        self Scanner.is_at_end if {
            false return
        }

        0 self Scanner.peek expected != if {
            false
        } else {
            self::current @ 1 + self::current !
            self::token_end @ 1 + self::token_end !
            true
        }
    }

    inline fn Scanner.peek(u64: offset *Scanner: self) -> [char] {
        '\0' offset self::source HString.at Opt.unwrap_or 
    }

    inline fn Scanner.special_chars() -> [Vec<char>] {

        Vec.new::<char> as [mut vec]
        ' '  *vec Vec.push
        '\n' *vec Vec.push
        '\t' *vec Vec.push
        '\r' *vec Vec.push
        ':'  *vec Vec.push
        '{'  *vec Vec.push
        '}'  *vec Vec.push
        '['  *vec Vec.push
        ']'  *vec Vec.push
        '('  *vec Vec.push
        ')'  *vec Vec.push
        '<'  *vec Vec.push
        '>'  *vec Vec.push
        vec

    }

    fn Scanner.identifier(*Scanner: self) -> [Opt<HayError>] {

        Keyword.keywords as [keywords]
        Scanner.special_chars as [chars]

        while 0 self Scanner.peek &chars Vec.contains 
                self Scanner.is_at_end lnot land
        {
            self Scanner.advance drop
        } 

        self::start @
        self::current @ self::start @ -
        self::source HString.as_str 
        Str.substr as [ident]

        ident &keywords Map.get as [maybe_kind]
        &maybe_kind Opt.is_some if {
            maybe_kind Opt.unwrap as [kind]
            kind::tag @ TokenKindTag::Syscall == if {
                self Scanner.syscall as [result]
                &result Opt.is_some if {
                    result return
                }
            } else {
                kind @ self Scanner.add_token
            }
        }

        Opt.None::<HayError>

    }

    fn Scanner.syscall(*Scanner: self) -> [Opt<HayError>] {
        '(' self Scanner.matches lnot if {

            "Expected " HString.new as [mut msg]
            Marker::LeftParen *msg Marker.format
            " after `syscall`." *msg HString.push_str 

            msg
            self::file HString.clone 
            self::line @ 
            self::token_start @ 
            self::token_end @
            Loc.new
            HayError.new
            Opt.Some return

        }

        self Scanner.advance as [c]
        c char.parse_u8 as [maybe_n] {
            &maybe_n Opt.is_some if {
                maybe_n Opt.unwrap as [n]
                n 0u8 > n 7u8 < land if {
                    n
                } else {
                    "Expected `1..6` after `syscall(`, but found " HString.new as [mut msg]
                    c *msg HString.push
                    
                    msg
                    self::file HString.clone 
                    self::line @ 
                    self::token_start @ 
                    self::token_end @
                    Loc.new
                    HayError.new
                    Opt.Some return
                }
            } else {
                "Expected `1..6` after `syscall(`" HString.new
                self::file HString.clone 
                self::line @ 
                self::token_start @ 
                self::token_end @
                Loc.new
                HayError.new
                Opt.Some return
            }
        }

    }

}