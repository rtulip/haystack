include "sys_x86_64.hay"
include "write.hay"
include "print.hay"

impl Write<Str> {
    fn write(Str: s u64: fd) {
        s::size s::data fd sys_write drop
    }
}

impl Write<u64> {
    fn write(u64: n u64: fd) {
        var char[32]: buffer
        n buffer @ u64.to_str fd write
    }
}

impl Write<u8> {
    fn write(u8: n u64: fd) {
        n cast(u64) fd write
    }
}

impl Write<bool> {
    fn write(bool: b u64: fd) {
        b if { "true" } else { "false" }
        fd write
    }
}

impl Write<char> {
    fn write(char: c u64: fd) {
        1 &c cast(Str) fd write
    }
}

struct cStr {
    pub u64: size
    pub &char: data
}

fn cStr.to_Str(cStr: cs) -> [Str] {
    cs::size 1 - cs::data cast(Str)
}

fn Str.to_cStr(Str: s Arr<char>: buffer) -> [cStr bool] {
    s::size 1 + buffer::size >= if {
        "Buffer is too small to null terminate string" println
        s as [str] {
            str::size str::data 
        } cast(cStr) false
    } else {
        // null terminate the string.
        s as [str] {
            str::size str::data 
        } buffer::data memcpy
        '\0' buffer::data s::size ptr+_mut !
        s::size 1 + buffer::data cast(cStr) true
    }
}


fn Str.drop_left(Str: s) -> [Str] {
    s::size 0 == if {
        s
    } else {
        s::size 1 - s::data 1 ptr+ cast(Str)
    }
}

fn Str.drop_right(u64: n Str: s) -> [Str] {
    s::size n >= if {
        s::size n - s::data n ptr+ cast(Str)
    } else {
        0 s::data s::size ptr+ cast(Str)
    }
}

fn Str.size(Str: s) -> [u64] {
    s::size
}

fn Str.substr(u64: start u64: len Str: s) -> [Str] {
    len s::data start ptr+ cast(Str)
}

fn Str.split_left(u64: n Str: s) -> [Str Str] {
    n s::data cast(Str)
    s::size n - s::data n ptr+ cast(Str)
}

fn u64.to_str(u64: u Arr<char>: chars) -> [Str] {

    chars::size 20 < if {
        "Must provide at least 20 chars of buffer to copy u64" println
        1 exit 
    }

    0 u == if {
        "0" as [str] { str::size str::data } chars::data memcpy
        1 chars::data cast(Str) 
    } else {
        19 u while dup 0 != {
            as [i x]
            x 10 % cast(char) '0' + chars::data i ptr+_mut !
            
            i 1 -
            x 10 /    
        } drop
        
        as [i]
        19 i - chars::data i 1 + ptr+ cast(Str)
    }    

}

fn Str.equals(Str: s1 Str:s2) -> [bool] {

    s1::size s2::size != if {
        false return
    }

    0 while dup s1::size < {
        as [i]

        s1::data i ptr+ @ 
        s2::data i ptr+ @ != if {
            false return
        }

        i 1 + 
    } drop

    true

}

fn Str.starts_with(Str: s2 Str: s1) -> [bool] {

    0 s2::size s1 Str.substr
    s2 
    Str.equals 

}

