include "opt.hay"
enum ResultTag {
    Ok
    Err
}

union ResultKind<T E> {
    T: ok
    E: err
}

struct Result<T E> {
    ResultKind<T E>: kind
    ResultTag: tag
    
impl:

    fn Result.Ok<T E>(T) -> [Result<T E>] {
        cast(ResultKind<T E>)
        ResultTag::Ok
        cast(Result<T E>)
    }

    fn Result.Err<T E>(E) -> [Result<T E>] {
        cast(ResultKind<T E>)
        ResultTag::Err
        cast(Result<T E>)
    }

    fn Result.is_ok<T E>(&Result<T E>: self) -> [bool] {
        self::tag @ ResultTag::Ok ==
    }

    fn Result.is_err<T E>(&Result<T E>: self) -> [bool] {
        self::tag @ ResultTag::Err ==
    }

    fn Result.take_is_ok<T E>(Result<T E>: self) -> [bool] {
        &self Result.is_ok
    }

    fn Result.take_is_err<T E>(Result<T E>: self) -> [bool] {
        &self Result.is_err
    }

    fn Result.unwrap<T E>(Result<T E>: self) -> [T] {

        &self Result.is_err if {
            "Tried to `unwrap` an Error result" println
            1 exit
        }
        self::kind::ok
    }

    fn Result.unwrap_err<T E>(Result<T E>: self) -> [E] {

        &self Result.is_ok if {
            "Tried to `unwrap_err` on an Ok result" println
            1 exit
        }
        self::kind::err
    }

    fn Result.ok<T E>(Result<T E>: self) -> [Opt<T>] {
        &self Result.is_ok if {
            self Result.unwrap Opt.Some
        } else {
            Opt.None::<T>
        }
    }

}