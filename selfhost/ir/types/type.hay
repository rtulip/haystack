include "stack.hay"
include "linear_map.hay"
include "selfhost/ir/tokens/token.hay"

struct EnumType {
    Str: name
    Stack<Str>: Variants
}

struct PointerType<T> {
    *T: inner
}

struct StructType<T> {
    Str: name
    *Map<*T>: members
}

struct GenericStructBaseType<T> {
    StructType<T>: base
    *Stack<*T>: generics
}

struct GenericStructInstanceType<T> {
    *GenericStructBaseType<T>: base
    StructType<T>: instance
    *Stack<*T>: alias_list
}

struct ResolvedStructType<T> {
    *StructType<T>: base
    StructType<T>: instance
}

struct UnionType<T> {
    Str: name
    *Map<*T>: members
}

struct GenericUnionBaseType<T> {
    UnionType<T>: base
    *Stack<*T>: generics
}

struct GenericUnionInstanceType<T> {
    *GenericUnionBaseType<T>: base
    UnionType<T>: instance 
    *Stack<*T>: alias_list
}

struct ResolvedUnionType<T> {
    *UnionType<T>: base
    UnionType<T>: instance 
}

enum TypeKind {
    U64
    U8
    Bool
    Enum
    Placeholder
    Pointer
    Struct
    GenericStructBase
    GenericStructInstance
    ResolvedStruct
    Union
    GenericUnionBase
    GenericUnionInstance
    ResolvedUnion
}

union TypeValue<T> {
    u64:                          U64
    u64:                          U8
    u64:                          Bool
    EnumType:                     Enum
    Str:                          Placeholder
    PointerType<T>:               Pointer
    StructType<T>:                Struct
    GenericStructBaseType<T>:     GenericStructBase
    GenericStructInstanceType<T>: GenericStructInstance
    ResolvedStructType<T>:        ResolvedStruct
    UnionType<T>:                 Union
    GenericUnionBaseType<T>:      GenericUnionBase
    GenericUnionInstanceType<T>:  GenericUnionInstance
    ResolvedUnionType<T>:         ResolvedUnion
}

struct Type {
    TypeValue<Type>: type
    TypeKind: tag
}


fn TypeKind.fputs(TypeKind: kind u64: fd) {

    kind TypeKind::U64 == if {
        "TypeKind::u64" fd fputs
    } else kind TypeKind::U8 == if {
        "TypeKind::u8" fd fputs
    } else kind TypeKind::Bool == if {
        "TypeKind::bool" fd fputs
    } else kind TypeKind::Enum == if {
        "TypeKind::enum" fd fputs
    } else kind TypeKind::Placeholder == if {
        "TypeKind::placeholder" fd fputs
    } else kind TypeKind::Pointer == if {
        "TypeKind::pointer" fd fputs
    } else kind TypeKind::Struct == if {
        "TypeKind::Struct" fd fputs
    } else kind TypeKind::GenericStructBase == if {
        "TypeKind::GenericBaseStruct" fd fputs
    } else kind TypeKind::GenericStructInstance == if {
        "TypeKind::GenericStructInstance" fd fputs
    } else kind TypeKind::ResolvedStruct == if {
        "TypeKind::ResolvedStruct" fd fputs
    } else kind TypeKind::Union == if {
        "TypeKind::Union" fd fputs
    } else kind TypeKind::GenericUnionBase == if {
        "TypeKind::GenericUnionBase" fd fputs
    } else kind TypeKind::GenericUnionInstance == if {
        "TypeKind::GenericUnionInstance" fd fputs
    }else kind TypeKind::ResolvedUnion == if {
        "TypeKind::ResolvedUnion" fd fputs
    } else {
        "Unknown type kind variant!" putlns
        1 exit
    }

}

fn TypeKind.puts(TypeKind) {
    1 TypeKind.fputs
}

fn Type.fputs(Type: type u64: fd) {

    type::tag as [kind]

    kind TypeKind::U64 == if {
        "u64" fd fputs
    } else kind TypeKind::U8 == if {
        "u8" fd fputs
    } else kind TypeKind::Bool == if {
        "bool" fd fputs
    } else kind TypeKind::Enum == if {
        type::type::Enum::name fd fputs
    } else kind TypeKind::Placeholder == if {
        type::type::Placeholder fd fputs
    } else kind TypeKind::Pointer == if {
        "*" fd fputs
        type::type::Pointer::inner @ fd Type.fputs
    } else kind TypeKind::Struct == if {
        type::type::Struct::name fd fputs
    } else kind TypeKind::GenericStructBase == if {
        "Printing generic structs isn't implemented yet" putlns
        1 exit 
        type::type::GenericStructBase::base::name fd fputs
        
        "<" fd fputs

         

        ">" fd fputs
    } else kind TypeKind::GenericStructInstance == if {
        "Type::GenericStructInstance" fd fputs
    } else kind TypeKind::ResolvedStruct == if {
        "Type::ResolvedStruct" fd fputs
    } else kind TypeKind::Union == if {
        "Type::Union" fd fputs
    } else kind TypeKind::GenericUnionBase == if {
        "Type::GenericUnionBase" fd fputs
    } else kind TypeKind::GenericUnionInstance == if {
        "Type::GenericUnionInstance" fd fputs
    }else kind TypeKind::ResolvedUnion == if {
        "Type::ResolvedUnion" fd fputs
    } else {
        "Unknown type kind variant!" putlns
        1 exit
    }

}

fn Type.puts(Type) {
    1 Type.fputs
}

fn Type.new_empty(TypeKind: kind) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) kind cast(Type) type_p !
    type_p
}

fn Type.u64() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::U64 cast(Type) type_p !
    type_p
}

fn Type.u8() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::U8 cast(Type) type_p !
    type_p
}

fn Type.bool() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::Bool cast(Type) type_p !
    type_p
}

fn Type.Pointer(*Type: inner) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    inner cast(PointerType) cast(TypeValue<Type>) TypeKind::Pointer cast(Type) type_p !
    type_p
}

fn Type.Struct(Str: name *Map<*Type>: members) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name members cast(StructType) cast(TypeValue<Type>) TypeKind::Struct cast(Type) type_p !
    type_p
}

fn Type.Placeholder(Str: name) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name cast(TypeValue<Type>) TypeKind::Placeholder cast(Type) type_p !
    type_p
}

fn Type.GenericStructBase(Str: name *Map<*Type>: members *Stack<*Type>: generics) -> [*Type] {

    malloc_obj::<Type> as [type_p]
    name members cast(StructType) generics cast(GenericStructBaseType)
        cast(TypeValue<Type>) TypeKind::Struct cast(Type) type_p !
    type_p

}

fn Type.name(*Type: typ_p) -> [Str] {

    typ_p @ as [typ]

    typ::tag TypeKind::U64 == if {
        "u64"
    } else typ::tag TypeKind::U8 == if {
        "u8"
    } else typ::tag TypeKind::Bool == if {
        "bool"
    } else typ::tag TypeKind::Enum == if {
        typ::type::Enum::name 
    } else typ::tag TypeKind::Placeholder == if {
        typ::type::Placeholder
    } else typ::tag TypeKind::Pointer == if {
        typ::type::Pointer::inner Type.name as [inner]

        inner::size 1 + malloc::<u8> as [name]
        "*" split name::data memcpy
        inner split name::data 1 ptr+ memcpy
        name split cast(Str)

    } else typ::tag TypeKind::Struct == if {
        typ::type::Struct::name
    } else {
        "NotImplementedYet"
        "Getting names of " puts typ::tag TypeKind.puts " isn't implemented yet" putlns
        1 exit 
    }
 
}

fn Type.deep_check_generics(
    *Type: typ_p
    *Map<*Type>: types
    *Stack<*Type>: visited_p
) -> [*Stack<*Type>] {

    Stack.new::<*Type> as [stk]

    visited_p @ as [visited]
    false 0 while dup visited::slice::size < {
        as [i]
        i visited::slice Arr.get cast(u64) typ_p cast(u64) == lor
        i 1 + 
    } drop if {
        stk
    } else {

        typ_p visited_p Stack.push

        typ_p @ as [typ]
        typ::tag TypeKind::U64  ==
        typ::tag TypeKind::U8   == lor
        typ::tag TypeKind::Bool == lor
        typ::tag TypeKind::Enum == lor if {
            stk
        } else typ::tag TypeKind::Placeholder == if {
            typ_p stk Stack.push
            stk
        } else typ::tag TypeKind::Pointer == if {
            typ::type::Pointer::inner types visited_p Type.deep_check_generics
        } else typ::tag TypeKind::Struct                 ==
               typ::tag TypeKind::Union                 == lor 
               typ::tag TypeKind::GenericStructBase     == lor
               typ::tag TypeKind::GenericStructInstance == lor
               typ::tag TypeKind::ResolvedStruct        == lor
               typ::tag TypeKind::GenericUnionBase      == lor
               typ::tag TypeKind::GenericUnionInstance  == lor
               typ::tag TypeKind::ResolvedUnion         == lor if {
            
            typ::tag TypeKind::Struct == if {
                typ::type::Struct::members
            } else typ::tag TypeKind::Union == if {
                typ::type::Union::members
            } else typ::tag TypeKind::GenericStructBase == if {
                typ::type::GenericStructBase::base::members
            } else typ::tag TypeKind::GenericStructInstance == if {
                typ::type::GenericStructInstance::instance::members
            } else typ::tag TypeKind::ResolvedStruct == if {
                typ::type::ResolvedStruct::instance::members
            } else typ::tag TypeKind::GenericUnionBase == if {
                typ::type::GenericUnionBase::base::members
            } else typ::tag TypeKind::GenericUnionInstance == if {
                typ::type::GenericUnionInstance::instance::members
            } else typ::tag TypeKind::ResolvedUnion == if {
                typ::type::ResolvedUnion::instance::members
            } else {
                typ::type::Struct::members
                "Unreachable" putlns
                1 exit
            } as [members_p]

            members_p @ as [members] {members::values @ as [values] values::slice } as [members] 

            0 while dup members::size < {

                as [i]

                i members Arr.get as [member]

                member types visited_p Type.deep_check_generics as [generics]

                while generics Stack.peek Opt.is_some {
                    generics Stack.pop Opt.unwrap stk Stack.push
                }

                generics Stack.destroy

                i 1 +

            } drop

            stk

        } else {
            "Unhandled type in Type.deep_check_generics" putlns
            1 exit
            stk
        }
    }
}

fn Type.shallow_check_generics(
    *Type: typ_p
    *Map<*Type>: types
) -> [*Stack<*Type>] {

    typ_p @ as [typ]
    Stack.new::<*Type> as [stk]

    typ::tag TypeKind::U64 ==
    typ::tag TypeKind::U8 == lor
    typ::tag TypeKind::Bool == lor
    typ::tag TypeKind::Enum == lor
    typ::tag TypeKind::Struct == lor
    typ::tag TypeKind::Union == lor
    typ::tag TypeKind::ResolvedStruct == lor
    typ::tag TypeKind::ResolvedUnion == lor if {
    } else typ::tag TypeKind::Placeholder == if {
        typ_p stk Stack.push
    } else typ::tag TypeKind::GenericStructBase ==
           typ::tag TypeKind::GenericStructInstance == lor
           typ::tag TypeKind::GenericUnionBase == lor
           typ::tag TypeKind::GenericUnionInstance == lor if {
        
        typ::tag TypeKind::GenericStructBase == if {
            typ::type::GenericStructBase::generics
        } else typ::tag TypeKind::GenericStructInstance == if {
            typ::type::GenericStructInstance::alias_list 
        } else typ::tag TypeKind::GenericUnionBase == if {
            typ::type::GenericUnionBase::generics
        } else typ::tag TypeKind::GenericUnionInstance == if {
            typ::type::GenericUnionInstance::alias_list
        } else {
            stk
            "Unreachable state in Type.shallow_check_generics" putlns
            1 exit
        } @ as [gen]

        0 while dup gen::slice::size < {
            as [i]

            i gen::slice Arr.get stk Stack.push

            i 1 +
        } drop

    } else {
        "Unhandled type in Type.shallow_check_generics" putlns
        1 exit
    }

    stk

}

fn Type.size (*Type: typ_p Token: token *Map<*Type>: types) -> [u64] {
    typ_p @ as [typ]
    typ::tag TypeKind::U64     == 
    typ::tag TypeKind::U8      == lor
    typ::tag TypeKind::Bool    == lor
    typ::tag TypeKind::Pointer == lor
    typ::tag TypeKind::Enum    == lor if {
        1
    } else typ::tag TypeKind::Struct == 
           typ::tag TypeKind::ResolvedStruct == lor if {
        
        typ::tag TypeKind::Struct == if {
            typ::type::Struct::members
        } else typ::tag TypeKind::ResolvedStruct == if {
            typ::type::ResolvedStruct::instance::members
        } else {
            typ::type::Struct::members
            "Unreachable branch in Type.size" putlns
            1 exit
        } @ as [map] { map::values @ as [values] values::slice } as [members] 

        0 0 while dup members::size < {
            as [sum i]

            i members Arr.get token types Type.size sum +
            i 1 +
        } drop
    } else typ::tag TypeKind::Union == 
           typ::tag TypeKind::ResolvedUnion == lor if {
        
        typ::tag TypeKind::Union == if {
            typ::type::Union::members
        } else typ::tag TypeKind::ResolvedUnion == if {
            typ::type::ResolvedUnion::instance::members
        } else {
            typ::type::Union::members
            "Unreachable branch in Type.size" putlns
            1 exit
        } @ as [map] { map::values @ as [values] values::slice } as [members] 

        0 members Arr.get token types Type.size
        1 while dup members::size < {
            as [max i]

            i members Arr.get token types Type.size as [size] 
            
            size max > if {
                size
            } else {
                max
            }

            i 1 +
        } drop
    } else typ::tag TypeKind::GenericUnionBase == if {
        token::loc Loc.puts
        ": Size of generic union base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericUnionInstance == if {
        token::loc Loc.puts
        ": Size of generic union instance is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericStructBase == if {
        token::loc Loc.puts
        ": Size of generic struct base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericStructInstance == if {
        token::loc Loc.puts
        ": Size of generic union base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::Placeholder == if {
        token::loc Loc.puts
        ": Size of placeholder types is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else {
        "Unrecognized type tag in Type.size" putlns
        1 exit 
        0
    }
}

fn Type.width(*Type: typ_p) -> [u64] {
    typ_p @ as [typ]
    typ::tag TypeKind::U8 == if {
        1
    } else {
        8
    }
}