fn sys_write(u64 *u8 u64) -> [u64] {
    1 syscall(3)
}

fn sys_exit(u64) {
    60 syscall(1) drop
}

fn fputs(Str: s u64: fd) {
    s split fd sys_write drop
}

// TODO: replace `1` with a constant for stdout
fn puts(Str) {
    1 fputs
}

fn putlns(Str) {
    puts "\n" puts
}

fn exit(u64) {
    sys_exit 
}

fn fputu(u64: u u64: fd) {
    var u8[20]: buffer
    buffer @ as [chars]

    0 u == if {
        "0" fd fputs
    }


    19 u while dup 0 != {
        as [i x]
        x 10 % 48 + cast(u8) i chars Arr.set
        
        i 1 -
        x 10 /
    } drop
    
    as [i]
    19 i - chars::data i 1 + ptr+ cast(Str) fd fputs
}

fn putu(u64) {
    1 fputu
}

fn putlnu(u64) {
    putu "\n" puts
}

fn fputb(bool: b u64: fd) {
    b if { "true" fd fputs } else { "false" fd fputs }
}

fn putb(bool) {1 fputb}

fn putlnb(bool) {
    putb "\n" puts
}

fn Arr.set<T>(T: value u64: idx Arr<T>: arr) {

    idx arr::size >= if {
        "Index out of bounds: " puts
        idx putlnu
        1 exit
    }
    value arr::data idx ptr+ !
}

fn Arr.get<T>(u64: idx Arr<T>: arr) -> [T] {
    idx arr::size >= if {
        "Index out of bounds: " puts
        idx putlnu
        1 exit
    }
    arr::data idx ptr+ @
}