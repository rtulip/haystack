
// Note: <T> marks that dup is generic over one variable T
// Note: T:value will remove T from the stack and associate it with the identifier `value`.
// Note: [T, T] indicates that two instances of T will be left on the stack after calling `dup<T>` 
// Note: `value` is dropped after returning from dup
fn dup<T>(T: value) -> [T T] {
    value value
}

// Note: you can omit naming a variable, which will not consume it from the stack.
fn add_u64s(u64 u64) -> [u64] { + }

// Note: mixing named and un-named inputs will not be supported.
// fn doesnt_compile(u64 u64: b) {} // Compiler Error

fn assign_names(u64 u64) -> [u64] {
    // Note: You can consume items from the top of the stack to give them a variable name
    var [a b]
    a b +
}

// Note: No return value, no `-> [...]` 
fn update_variable(u64: value) {
    // `->` operator will consume the top element of the stack and save it back u64o the variable.
    value 5 +  -> value
}

fn temporary_variables() {
    // Initialized variables
    var string: "Hello World"
    // These are equivalent
    "Hello World" var [string]
    
    "New Str" -> string.data
}

// Structs will hav members be named.
struct Str {
    u64: size
    ptr: data
}

fn puts(Str) {
    // ..
}

// Should be able to create aliases to types.
type myu64: u64

fn main() {

    // Note: calling generic functions can be done without annotations.
    "Hello World" dup 
    puts puts
}
