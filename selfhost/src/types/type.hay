include "hstring.hay"
include "selfhost/src/types/function/function.hay"
include "selfhost/src/types/function/generic.hay"
include "selfhost/src/types/function/unchecked.hay"
include "selfhost/src/types/record/base.hay"
include "selfhost/src/types/record/instance.hay"
include "selfhost/src/types/record/pre_declaration.hay"
include "selfhost/src/types/record/record.hay"
include "selfhost/src/types/enum.hay"
include "selfhost/src/types/pointer.hay"

enum TypeTag {
    U8
    U64
    Char
    Bool
    Never
    Pointer
    Record
    RecordPreDeclaration
    GenericRecordBase
    GenericRecordInstance
    Enum
    GenericFunction
    UncheckedFunction
    Function
}

union TypeKind {
    u8                   : u8
    u64                  : u64
    char                 : char
    bool                 : bool
    Pointer              : pointer
    Record               : record
    RecordPreDeclaration : pre_decl
    GenericRecordBase    : base
    GenericRecordInstance: instance
    Enum                 : enum_
    GenericFunction      : gen_func
    UncheckedFunction    : unchecked_func
    Function             : func
}

struct Type {
    TypeKind: kind
    TypeTag : tag

impl: 

    inline fn Type.U8(u8) -> [Type] {
        cast(TypeKind)
        TypeTag::U8
        cast(Type)
    }

    inline fn Type.U64(u64) -> [Type] {
        cast(TypeKind)
        TypeTag::U64
        cast(Type)
    }

    inline fn Type.Char(char) -> [Type] {
        cast(TypeKind)
        TypeTag::Char
        cast(Type)
    }

    inline fn Type.Bool(bool) -> [Type] {
        cast(TypeKind)
        TypeTag::Bool
        cast(Type)
    }

    inline fn Type.Never() -> [Type] {
        0 cast(TypeKind)
        TypeTag::Never
        cast(Type)
    }

    inline fn Type.Pointer(Pointer) -> [Type] {
        cast(TypeKind)
        TypeTag::Pointer
        cast(Type)
    }

    inline fn Type.Record(Record) -> [Type] {
        cast(TypeKind)
        TypeTag::Record
        cast(Type)
    }

    inline fn Type.RecordPreDeclaration(RecordPreDeclaration) -> [Type] {
        cast(TypeKind)
        TypeTag::RecordPreDeclaration
        cast(Type)
    }

    inline fn Type.GenericRecordBase(GenericRecordBase) -> [Type] {
        cast(TypeKind)
        TypeTag::GenericRecordBase
        cast(Type)
    }

    inline fn Type.GenericRecordInstance(GenericRecordInstance) -> [Type] {
        cast(TypeKind)
        TypeTag::GenericRecordInstance
        cast(Type)
    }

    inline fn Type.Enum(Enum) -> [Type] {
        cast(TypeKind)
        TypeTag::Enum
        cast(Type)
    }

    inline fn Type.GenericFunction(GenericFunction) -> [Type] {
        cast(TypeKind)
        TypeTag::GenericFunction
        cast(Type)
    }

    inline fn Type.UncheckedFunction(UncheckedFunction) -> [Type] {
        cast(TypeKind)
        TypeTag::UncheckedFunction
        cast(Type)
    }

    inline fn Type.Function(Function) -> [Type] {
        cast(TypeKind)
        TypeTag::Function
        cast(Type)
    }

    fn Type.id(&Type: self) -> [HString] {
        self::tag @ TypeTag::U8 == if {
            "u8" HString.new
        } else self::tag @ TypeTag::U64 == if {
            "u64" HString.new
        } else self::tag @ TypeTag::Char == if {
            "char" HString.new
        } else self::tag @ TypeTag::Bool == if {
            "bool" HString.new
        } else self::tag @ TypeTag::Never == if {
            "!" HString.new
        } else self::tag @ TypeTag::Pointer == if {
            self::kind::pointer::mutable @ if {
                "*" HString.new
                self::kind::pointer::inner HString.clone HString.format
            } else {
                "&" HString.new
                self::kind::pointer::inner HString.clone HString.format
            }
        } else self::tag @ TypeTag::Record == if {
            self::kind::record::name::lexeme HString.clone
        } else self::tag @ TypeTag::RecordPreDeclaration == if {
            "Cannot take id of Pre-declared type" putlns
            1 exit
            "" HString.new
        } else self::tag @ TypeTag::GenericRecordBase == if {
            self::kind::base::name::lexeme HString.clone
        } else self::tag @ TypeTag::GenericRecordInstance == if {
            self::kind::instance::alias_list as [alias_list]
            self::kind::instance::base HString.clone
            '<' HString.push

            0 while dup alias_list Vec.len 1 - < {
                as [i]
                i alias_list Vec.get Opt.unwrap 
                HString.as_str HString.push_str
                i 1 +
            } drop

            alias_list Vec.last Opt.unwrap HString.as_str HString.push_str
            '>' HString.push

        } else self::tag @ TypeTag::Enum == if {
            self::kind::enum_::name::lexeme HString.clone
        } else self::tag @ TypeTag::GenericFunction == if {
            "Cannot take id of Generic Function" putlns
            1 exit
            "" HString.new
        } else self::tag @ TypeTag::UncheckedFunction == if {
            "Cannot take id of UncheckedFunction Function" putlns
            1 exit
            "" HString.new
        } else self::tag @ TypeTag::Function == if {
            "Cannot take id of Function" putlns
            1 exit
            "" HString.new
        } else {
            "Type.id unreachable!" putlns
            1 exit
            "" HString.new
        }
    }

}
