include "stack.hay"
include "linear_map.hay"
include "selfhost/ir/tokens/token.hay"

struct EnumType {
    Str: name
    Arr<Str>: Variants
}

struct PointerType<T> {
    *T: inner
}

struct StructType<T> {
    Str: name
    *Map<*T>: members
}

struct GenericStructBaseType<T> {
    StructType<T>: base
    *Stack<*T>: generics
}

struct GenericStructInstanceType<T> {
    *T: base
    StructType<T>: instance
    *Stack<*T>: alias_list
}

struct ResolvedStructType<T> {
    StructType<T>: instance
    *T: base
}

struct UnionType<T> {
    Str: name
    *Map<*T>: members
}

struct GenericUnionBaseType<T> {
    UnionType<T>: base
    *Stack<*T>: generics
}

struct GenericUnionInstanceType<T> {
    *T: base
    UnionType<T>: instance 
    *Stack<*T>: alias_list
}

struct ResolvedUnionType<T> {
    UnionType<T>: instance 
    *T: base
}

enum TypeKind {
    U64
    U8
    Bool
    Enum
    Placeholder
    Pointer
    Struct
    GenericStructBase
    GenericStructInstance
    ResolvedStruct
    Union
    GenericUnionBase
    GenericUnionInstance
    ResolvedUnion
}

union TypeValue<T> {
    u64:                          U64
    u64:                          U8
    u64:                          Bool
    EnumType:                     Enum
    Str:                          Placeholder
    PointerType<T>:               Pointer
    StructType<T>:                Struct
    GenericStructBaseType<T>:     GenericStructBase
    GenericStructInstanceType<T>: GenericStructInstance
    ResolvedStructType<T>:        ResolvedStruct
    UnionType<T>:                 Union
    GenericUnionBaseType<T>:      GenericUnionBase
    GenericUnionInstanceType<T>:  GenericUnionInstance
    ResolvedUnionType<T>:         ResolvedUnion
}

struct Type {
    TypeValue<Type>: type
    TypeKind: tag
}


fn TypeKind.fputs(TypeKind: kind u64: fd) {

    kind TypeKind::U64 == if {
        "TypeKind::u64" fd fputs
    } else kind TypeKind::U8 == if {
        "TypeKind::u8" fd fputs
    } else kind TypeKind::Bool == if {
        "TypeKind::bool" fd fputs
    } else kind TypeKind::Enum == if {
        "TypeKind::enum" fd fputs
    } else kind TypeKind::Placeholder == if {
        "TypeKind::placeholder" fd fputs
    } else kind TypeKind::Pointer == if {
        "TypeKind::pointer" fd fputs
    } else kind TypeKind::Struct == if {
        "TypeKind::Struct" fd fputs
    } else kind TypeKind::GenericStructBase == if {
        "TypeKind::GenericBaseStruct" fd fputs
    } else kind TypeKind::GenericStructInstance == if {
        "TypeKind::GenericStructInstance" fd fputs
    } else kind TypeKind::ResolvedStruct == if {
        "TypeKind::ResolvedStruct" fd fputs
    } else kind TypeKind::Union == if {
        "TypeKind::Union" fd fputs
    } else kind TypeKind::GenericUnionBase == if {
        "TypeKind::GenericUnionBase" fd fputs
    } else kind TypeKind::GenericUnionInstance == if {
        "TypeKind::GenericUnionInstance" fd fputs
    }else kind TypeKind::ResolvedUnion == if {
        "TypeKind::ResolvedUnion" fd fputs
    } else {
        "Unknown type kind variant!" putlns
        1 exit
    }

}

fn TypeKind.puts(TypeKind) {
    1 TypeKind.fputs
}

fn Type.fputs(Type: type u64: fd) {

    type::tag as [kind]

    kind TypeKind::U64 == if {
        "u64" fd fputs
    } else kind TypeKind::U8 == if {
        "u8" fd fputs
    } else kind TypeKind::Bool == if {
        "bool" fd fputs
    } else kind TypeKind::Enum == if {
        type::type::Enum::name fd fputs
    } else kind TypeKind::Placeholder == if {
        type::type::Placeholder fd fputs
    } else kind TypeKind::Pointer == if {
        "*" fd fputs
        type::type::Pointer::inner @ fd Type.fputs
    } else kind TypeKind::Struct == if {
        type::type::Struct::name fd fputs
    } else kind TypeKind::GenericStructBase == if {
        "Printing generic structs isn't implemented yet" putlns
        1 exit 
        type::type::GenericStructBase::base::name fd fputs
        
        "<" fd fputs

         

        ">" fd fputs
    } else kind TypeKind::GenericStructInstance == if {
        "Type::GenericStructInstance" fd fputs
    } else kind TypeKind::ResolvedStruct == if {
        "Type::ResolvedStruct" fd fputs
    } else kind TypeKind::Union == if {
        "Type::Union" fd fputs
    } else kind TypeKind::GenericUnionBase == if {
        "Type::GenericUnionBase" fd fputs
    } else kind TypeKind::GenericUnionInstance == if {
        "Type::GenericUnionInstance" fd fputs
    }else kind TypeKind::ResolvedUnion == if {
        "Type::ResolvedUnion" fd fputs
    } else {
        "Unknown type kind variant!" putlns
        1 exit
    }

}

fn Type.puts(Type) {
    1 Type.fputs
}

fn Type.new_empty(TypeKind: kind) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) kind cast(Type) type_p !
    type_p
}

fn Type.u64() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::U64 cast(Type) type_p !
    type_p
}

fn Type.u8() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::U8 cast(Type) type_p !
    type_p
}

fn Type.bool() -> [*Type] {
    malloc_obj::<Type> as [type_p]
    0 cast(TypeValue<Type>) TypeKind::Bool cast(Type) type_p !
    type_p
}

fn Type.Pointer(*Type: inner) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    inner cast(PointerType) cast(TypeValue<Type>) TypeKind::Pointer cast(Type) type_p !
    type_p
}

fn Type.Struct(Str: name *Map<*Type>: members) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name members cast(StructType) cast(TypeValue<Type>) TypeKind::Struct cast(Type) type_p !
    type_p
}

fn Type.Placeholder(Str: name) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name cast(TypeValue<Type>) TypeKind::Placeholder cast(Type) type_p !
    type_p
}

fn Type.GenericStructBase(Str: name *Map<*Type>: members *Stack<*Type>: generics) -> [*Type] {

    malloc_obj::<Type> as [type_p]
    name members cast(StructType) generics cast(GenericStructBaseType)
        cast(TypeValue<Type>) TypeKind::GenericStructBase cast(Type) type_p !
    type_p

}

fn Type.GenericStructInstance(*Type: base_p *Stack<*Type>: alias_list) -> [*Type] {

    base_p @ as [base]
    base::tag TypeKind::GenericStructBase == lnot if {
        "Type.GenericStructInstance Assertion failed" putlns
        "    * Expected base_p to be of Kind GenericStructBase" putlns 
        1 exit
    }

    malloc_obj::<Type> as [type_p]

    base_p
    base::type::GenericStructBase::base
    alias_list
    cast(GenericStructInstanceType) cast(TypeValue<Type>)
    TypeKind::GenericStructInstance cast(Type) type_p !

    type_p

}

fn Type.GenericUnionInstance(*Type: base_p *Stack<*Type>: alias_list) -> [*Type] {

    base_p @ as [base]
    base::tag TypeKind::GenericUnionBase == lnot if {
        "Type.GenericUnionInstance Assertion failed" putlns
        "    * Expected base_p to be of Kind GenericUnionBase" putlns 
        1 exit
    }

    malloc_obj::<Type> as [type_p]

    base_p
    base::type::GenericUnionBase::base
    alias_list
    cast(GenericUnionInstanceType)
    cast(TypeValue<Type>)
    TypeKind::GenericUnionInstance cast(Type) type_p !

    type_p

}

fn Type.Enum(Str: name Arr<Str>: variants) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name variants cast(EnumType) cast(TypeValue<Type>) TypeKind::Enum cast(Type) type_p !
    type_p
}

fn Type.Union(Str: name *Map<*Type>: variants) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name variants cast(UnionType) cast(TypeValue<Type>) TypeKind::Union cast(Type) type_p !
    type_p
}

fn Type.GenericUnionBase(Str: name *Map<*Type>: variants *Stack<*Type>: generics) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name variants cast(UnionType) generics cast(GenericUnionBaseType) cast(TypeValue<Type>) TypeKind::GenericUnionBase cast(Type) type_p !
    type_p
}

fn Type.ResolvedStruct(Str: name *Map<*Type>: members *Type: base) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name members cast(StructType) base cast(ResolvedStructType) cast(TypeValue<Type>) TypeKind::ResolvedStruct cast(Type) type_p !
    type_p
}

fn Type.ResolvedUnion(Str: name *Map<*Type>: members *Type: base) -> [*Type] {
    malloc_obj::<Type> as [type_p]
    name members cast(UnionType) base cast(ResolvedUnionType) cast(TypeValue<Type>) TypeKind::ResolvedUnion cast(Type) type_p !
    type_p
}

fn Type.name(*Type: typ_p) -> [Str] {

    typ_p @ as [typ]

    typ::tag TypeKind::U64 == if {
        "u64"
    } else typ::tag TypeKind::U8 == if {
        "u8"
    } else typ::tag TypeKind::Bool == if {
        "bool"
    } else typ::tag TypeKind::Enum == if {
        typ::type::Enum::name 
    } else typ::tag TypeKind::Placeholder == if {
        typ::type::Placeholder
    } else typ::tag TypeKind::Pointer == if {
        typ::type::Pointer::inner Type.name as [inner]

        inner::size 1 + malloc::<u8> as [name]
        "*" split name::data memcpy
        inner split name::data 1 ptr+ memcpy
        name split cast(Str)

    } else typ::tag TypeKind::Struct == if {
        typ::type::Struct::name
    } else typ::tag TypeKind::GenericStructInstance == if {
        
        Stack.new::<u8> as [new_str]
        typ::type::GenericStructInstance::base @ as [base]
        
        base::tag TypeKind::GenericStructBase == lnot if {
            "Asserition failed in Type.name" putlns
            1 exit
        }

        0 while dup base::type::GenericStructBase::base::name::size < {
            as [i]

            i base::type::GenericStructBase::base::name split cast(Arr) Arr.get
            new_str Stack.push
            i 1 + 
        } drop

        0 "<" split cast(Arr) Arr.get new_str Stack.push

        base::type::GenericStructBase::generics @ as [gen] {gen::slice} as [generics]
        typ::type::GenericStructInstance::alias_list @ as [alias] {alias::slice} as [assignments]
        0 while dup base::type::GenericStructBase::generics Stack.len < {
            as [i]

            i 0 != if {
                0 " " split cast(Arr) Arr.get new_str Stack.push
            }

            i generics Arr.get Type.name split cast(Arr) as [gen_name]
            0 while dup gen_name::size < {
                as [j]

                j gen_name Arr.get new_str Stack.push

                j 1 +
            } drop

            0 "=" split cast(Arr) Arr.get new_str Stack.push

            i assignments Arr.get Type.name split cast(Arr) as [assn_name]
            0 while dup assn_name::size < {
                as [j]
                j assn_name Arr.get new_str Stack.push
                j 1 +
            } drop 

            i 1 +
        } drop

        0 ">" split cast(Arr) Arr.get new_str Stack.push

        new_str Stack.len malloc::<u8> as [dest]
        new_str @ as [tmp] {
            tmp::len tmp::slice::data dest::data memcpy
        }

        new_str Stack.destroy

        dest split cast(Str)

    } else typ::tag TypeKind::ResolvedStruct == if {
        
        typ::type::ResolvedStruct::instance::name
    
    } else typ::tag TypeKind::GenericUnionInstance == if {
        
        Stack.new::<u8> as [new_str]
        typ::type::GenericUnionInstance::base @ as [base]
        
        base::tag TypeKind::GenericUnionBase == lnot if {
            "Asserition failed in Type.name" putlns
            1 exit
        }

        0 while dup base::type::GenericUnionBase::base::name::size < {
            as [i]

            i base::type::GenericUnionBase::base::name split cast(Arr) Arr.get
            new_str Stack.push
            i 1 + 
        } drop

        0 "<" split cast(Arr) Arr.get new_str Stack.push

        base::type::GenericUnionBase::generics @ as [gen] {gen::slice} as [generics]
        typ::type::GenericUnionInstance::alias_list @ as [alias] {alias::slice} as [assignments]
        0 while dup base::type::GenericUnionBase::generics Stack.len < {
            as [i]

            i 0 != if {
                0 " " split cast(Arr) Arr.get new_str Stack.push
            }

            i generics Arr.get Type.name split cast(Arr) as [gen_name]
            0 while dup gen_name::size < {
                as [j]

                j gen_name Arr.get new_str Stack.push

                j 1 +
            } drop

            0 "=" split cast(Arr) Arr.get new_str Stack.push

            i assignments Arr.get Type.name split cast(Arr) as [assn_name]
            0 while dup assn_name::size < {
                as [j]
                j assn_name Arr.get new_str Stack.push
                j 1 +
            } drop 

            i 1 +
        } drop

        0 ">" split cast(Arr) Arr.get new_str Stack.push

        new_str Stack.len malloc::<u8> as [dest]
        new_str @ as [tmp] {
            tmp::len tmp::slice::data dest::data memcpy
        }

        new_str Stack.destroy

        dest split cast(Str)

    } else {
        "NotImplementedYet"
        "Getting names of " puts typ::tag TypeKind.puts " isn't implemented yet" putlns
        1 exit 
    }
 
}

fn Type.deep_check_generics(
    *Type: typ_p
    *Map<*Type>: types
    *Stack<*Type>: visited_p
) -> [*Stack<*Type>] {

    Stack.new::<*Type> as [stk]

    visited_p @ as [visited]
    false 0 while dup visited::slice::size < {
        as [i]
        i visited::slice Arr.get cast(u64) typ_p cast(u64) == lor
        i 1 + 
    } drop if {
        stk
    } else {

        typ_p visited_p Stack.push

        typ_p @ as [typ]
        typ::tag TypeKind::U64  ==
        typ::tag TypeKind::U8   == lor
        typ::tag TypeKind::Bool == lor
        typ::tag TypeKind::Enum == lor if {
            stk
        } else typ::tag TypeKind::Placeholder == if {
            typ_p stk Stack.push
            stk
        } else typ::tag TypeKind::Pointer == if {
            typ::type::Pointer::inner types visited_p Type.deep_check_generics
        } else typ::tag TypeKind::Struct                 ==
               typ::tag TypeKind::Union                 == lor 
               typ::tag TypeKind::GenericStructBase     == lor
               typ::tag TypeKind::GenericStructInstance == lor
               typ::tag TypeKind::ResolvedStruct        == lor
               typ::tag TypeKind::GenericUnionBase      == lor
               typ::tag TypeKind::GenericUnionInstance  == lor
               typ::tag TypeKind::ResolvedUnion         == lor if {
            
            typ::tag TypeKind::Struct == if {
                typ::type::Struct::members
            } else typ::tag TypeKind::Union == if {
                typ::type::Union::members
            } else typ::tag TypeKind::GenericStructBase == if {
                typ::type::GenericStructBase::base::members
            } else typ::tag TypeKind::GenericStructInstance == if {
                typ::type::GenericStructInstance::instance::members
            } else typ::tag TypeKind::ResolvedStruct == if {
                typ::type::ResolvedStruct::instance::members
            } else typ::tag TypeKind::GenericUnionBase == if {
                typ::type::GenericUnionBase::base::members
            } else typ::tag TypeKind::GenericUnionInstance == if {
                typ::type::GenericUnionInstance::instance::members
            } else typ::tag TypeKind::ResolvedUnion == if {
                typ::type::ResolvedUnion::instance::members
            } else {
                typ::type::Struct::members
                "Unreachable" putlns
                1 exit
            } as [members_p]

            members_p @ as [members] {members::values @ as [values] values::slice } as [members] 

            0 while dup members::size < {

                as [i]

                i members Arr.get as [member]

                member types visited_p Type.deep_check_generics as [generics]

                while generics Stack.peek Opt.is_some {
                    generics Stack.pop Opt.unwrap stk Stack.push
                }

                generics Stack.destroy

                i 1 +

            } drop

            stk

        } else {
            "Unhandled type in Type.deep_check_generics" putlns
            1 exit
            stk
        }
    }
}

fn Type.shallow_check_generics(
    *Type: typ_p
    *Map<*Type>: types
) -> [*Stack<*Type>] {

    typ_p @ as [typ]
    Stack.new::<*Type> as [stk]

    typ::tag TypeKind::U64 ==
    typ::tag TypeKind::U8 == lor
    typ::tag TypeKind::Bool == lor
    typ::tag TypeKind::Enum == lor
    typ::tag TypeKind::Struct == lor
    typ::tag TypeKind::Union == lor
    typ::tag TypeKind::ResolvedStruct == lor
    typ::tag TypeKind::ResolvedUnion == lor if {
    } else typ::tag TypeKind::Placeholder == if {
        typ_p stk Stack.push
    } else typ::tag TypeKind::GenericStructBase ==
           typ::tag TypeKind::GenericStructInstance == lor
           typ::tag TypeKind::GenericUnionBase == lor
           typ::tag TypeKind::GenericUnionInstance == lor if {
        
        typ::tag TypeKind::GenericStructBase == if {
            typ::type::GenericStructBase::generics
        } else typ::tag TypeKind::GenericStructInstance == if {
            typ::type::GenericStructInstance::alias_list 
        } else typ::tag TypeKind::GenericUnionBase == if {
            typ::type::GenericUnionBase::generics
        } else typ::tag TypeKind::GenericUnionInstance == if {
            typ::type::GenericUnionInstance::alias_list
        } else {
            stk
            "Unreachable state in Type.shallow_check_generics" putlns
            1 exit
        } @ as [gen]

        0 while dup gen::slice::size < {
            as [i]

            i gen::slice Arr.get stk Stack.push

            i 1 +
        } drop

    } else {
        "Unhandled type in Type.shallow_check_generics" putlns
        1 exit
    }

    stk

}

fn Type.size (*Type: typ_p Token: token *Map<*Type>: types) -> [u64] {
    typ_p @ as [typ]
    typ::tag TypeKind::U64     == 
    typ::tag TypeKind::U8      == lor
    typ::tag TypeKind::Bool    == lor
    typ::tag TypeKind::Pointer == lor
    typ::tag TypeKind::Enum    == lor if {
        1
    } else typ::tag TypeKind::Struct == 
           typ::tag TypeKind::ResolvedStruct == lor if {
        
        typ::tag TypeKind::Struct == if {
            typ::type::Struct::members
        } else typ::tag TypeKind::ResolvedStruct == if {
            typ::type::ResolvedStruct::instance::members
        } else {
            typ::type::Struct::members
            "Unreachable branch in Type.size" putlns
            1 exit
        } @ as [map] { map::values @ as [values] values::slice } as [members] 

        0 0 while dup members::size < {
            as [sum i]

            i members Arr.get token types Type.size sum +
            i 1 +
        } drop
    } else typ::tag TypeKind::Union == 
           typ::tag TypeKind::ResolvedUnion == lor if {
        
        typ::tag TypeKind::Union == if {
            typ::type::Union::members
        } else typ::tag TypeKind::ResolvedUnion == if {
            typ::type::ResolvedUnion::instance::members
        } else {
            typ::type::Union::members
            "Unreachable branch in Type.size" putlns
            1 exit
        } @ as [map] { map::values @ as [values] values::slice } as [members] 

        0 members Arr.get token types Type.size
        1 while dup members::size < {
            as [max i]

            i members Arr.get token types Type.size as [size] 
            
            size max > if {
                size
            } else {
                max
            }

            i 1 +
        } drop
    } else typ::tag TypeKind::GenericUnionBase == if {
        token::loc Loc.puts
        ": Size of generic union base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericUnionInstance == if {
        token::loc Loc.puts
        ": Size of generic union instance is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericStructBase == if {
        token::loc Loc.puts
        ": Size of generic struct base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::GenericStructInstance == if {
        token::loc Loc.puts
        ": Size of generic union base is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else typ::tag TypeKind::Placeholder == if {
        token::loc Loc.puts
        ": Size of placeholder types is unknown" putlns
        "   * Trying to take size of: " puts typ_p Type.name as [name] 
        name putlns
        name split cast(Arr) free
        1 exit
        0
    } else {
        "Unrecognized type tag in Type.size" putlns
        1 exit 
        0
    }
}

fn Type.width(*Type: typ_p) -> [u64] {
    typ_p @ as [typ]
    typ::tag TypeKind::U8 == if {
        1
    } else {
        8
    }
}

fn Type.free_puts(*Type: t){
    t Type.name as [name]
    name puts
    name split cast(Arr) free
} 

fn Type.resolve_type(
    Token: token
    *Type: maybe_generic_t
    *Type: concrete_t
    *Map<*Type>: generic_map
    *Map<*Type>: types
) -> [*Type] {
    
    maybe_generic_t @ concrete_t @ as [gen_t con_t]

    gen_t::tag TypeKind::U64 == con_t::tag TypeKind::U64 == land if {
        concrete_t
    } else gen_t::tag TypeKind::U8 == con_t::tag TypeKind::U8 == land if {
        concrete_t
    } else gen_t::tag TypeKind::Bool == con_t::tag TypeKind::Bool == land if {
        concrete_t
    } else gen_t::tag TypeKind::Pointer == con_t::tag TypeKind::Pointer == land if {
        token
        gen_t::type::Pointer::inner
        con_t::type::Pointer::inner
        generic_map
        types
        Type.resolve_type Type.Pointer as [ptr_typ]
        ptr_typ Type.name as [name] {
            name types Map.contains if {
                name types Map.get Opt.unwrap
                name split cast(Arr) free
            } else {
                name ptr_typ types Map.insert drop
                ptr_typ
            }
        }
    } else gen_t::tag TypeKind::Placeholder == if {
        con_t::tag TypeKind::GenericStructBase ==
        con_t::tag TypeKind::GenericUnionBase == lor if {
            "This should be unreachable. Cannot assign a placeholder to generic base" putlns
            1 exit
        }

        gen_t::type::Placeholder concrete_t generic_map Map.insert as [maybe_prev_assignment] 
        maybe_prev_assignment Opt.is_some if {
            maybe_prev_assignment Opt.unwrap cast(u64)
            concrete_t cast(u64) != if {
                token::loc Loc.puts
                ": Type Error - Failed Type Resolution" puts
                "    * Type `" puts maybe_generic_t Type.name puts 
                "` cannot be assigned to `" puts
                concrete_t Type.name puts "` as it was previously assigned to `" puts
                maybe_prev_assignment Opt.unwrap Type.name puts "`" putlns
            }
        }

        concrete_t

    } else {
        "Resolving types for " puts gen_t::tag TypeKind.puts " isn't implemented yet" putlns
        1 exit
        maybe_generic_t
    }
}

fn Type.resolve_struct(
    Token: token
    *Type: gen_struct_t
    *Stack<*Type>: stack
    *Map<*Type>: types
) -> [*Type] {

    gen_struct_t @ as [typ]
    typ::tag TypeKind::GenericStructBase == lnot if {

        gen_struct_t
        "Type.resolve_struct should only be unse on GeneircStructBaseTypes..." putlns
        "    * Type: " puts Type.name as [name] {
            name putlns
            name split cast(Arr) free
        }
        "    * Stack: [" puts
        0 while dup stack Stack.len < {
            as [i]
            i stack Stack.slice Arr.get as [t]
            " " puts
            t Type.name as [name] {
                name puts
                name split cast(Arr) free
            }
            i 1 + 
        } drop
        " ]" putlns
        1 exit
    }

    stack Stack.len typ::type::GenericStructBase::base::members Map.len >= lnot if {
        token::loc Loc.puts
        ": Insufficient number of elements on the stack." putlns
        1 exit 
    }

    typ::type::GenericStructBase::base::members @ split as [idents members]

    Map.new::<*Type> as [map]
    Map.new::<*Type> as [resolved_members]

    stack Stack.slice as [stk_slice] {
        
        typ::type::GenericStructBase::base::members Map.len
        stk_slice::data
        stk_slice::size typ::type::GenericStructBase::base::members Map.len -
        ptr+
        cast(Arr)
    } as [stk]
    
    0 while dup members Stack.len < {
        as [i]

        i members Stack.slice Arr.get
        i stk Arr.get 
        Map.new::<*Type>
        as [member concrete m]

        token member concrete m types Type.resolve_type as [t]

        m @ split as [m_ident m_concrete]
        0 while dup m_ident Stack.len < {
            as [j]
            j m_ident    Stack.slice Arr.get as [placeholder]
            j m_concrete Stack.slice Arr.get as [con_t]
            placeholder con_t map Map.insert as [maybe_t]

            maybe_t Opt.is_some if {
                maybe_t Opt.unwrap cast(u64) con_t cast(u64) != if {
                    token::loc Loc.puts
                    ": Type resolution failure in generic struct resolution" putlns
                    "    * Type `" puts placeholder puts "` cannot be assigned to `" puts
                    con_t Type.name puts "` as it was previously assigned to `" puts
                    maybe_t Opt.unwrap Type.name puts "`" putlns 
                }
            }
            j 1 +
        } drop

        m Map.destroy

        i 1 + 
    } drop

    gen_struct_t @ as [tmp_t] {
        tmp_t::type::GenericStructBase::base::name split cast(Arr)
        tmp_t::type::GenericStructBase::generics
    }  as [base_name generics]
    Stack.new::<u8> as [new_name_buffer]

    0 while dup base_name::size < {
        as [i]
        i base_name Arr.get
        new_name_buffer Stack.push
        i 1 +
    } drop

    0 "<" split cast(Arr) Arr.get new_name_buffer Stack.push

    0 while dup generics Stack.len < {
        as [i]

        i 0 != if {
            0 " " split cast(Arr) Arr.get new_name_buffer Stack.push
        }

        i generics Stack.slice Arr.get @ as [gen_t]
        
        gen_t::tag TypeKind::Placeholder == lnot if {
            "Assertion failed in Type.resolve_struct. Expected all generics to be Placeholders" putlns
            1 exit 
        }
        
        gen_t::type::Placeholder map Map.get as [maybe_assn_t]

        maybe_assn_t Opt.is_none if {
            token::loc Loc.puts
            ": Some types were not resoled during cast: " puts
            gen_t::type::Placeholder putlns
            1 exit
        }
        maybe_assn_t Opt.unwrap as [assn_t]
        assn_t Type.name as [assn_t_name]        
        0 while dup assn_t_name::size < {
            as [j]
            j assn_t_name split cast(Arr) Arr.get new_name_buffer Stack.push
            j 1 + 
        } drop

        i 1 + 

    } drop

    0 ">" split cast(Arr) Arr.get new_name_buffer Stack.push

    new_name_buffer Stack.len malloc::<u8> split cast(Str) as [resolved_name]
    new_name_buffer Stack.slice split resolved_name::data memcpy
    new_name_buffer Stack.destroy

    resolved_name types Map.contains if {
        resolved_name types Map.get Opt.unwrap
        resolved_name split cast(Arr) free
        map Map.destroy
        resolved_members Map.destroy
    } else {
        resolved_name
        resolved_members 
        gen_struct_t
        Type.ResolvedStruct as [resolved_t]
        
        resolved_name resolved_t types Map.insert drop
        resolved_t
    }

}

fn Type.is_generic(*Type: typ_p) -> [bool] {

    typ_p @ as [typ]
    typ::tag TypeKind::Pointer == if {
        typ::type::Pointer::inner Type.is_generic
    } else typ::tag TypeKind::Placeholder           ==
           typ::tag TypeKind::GenericStructBase     == lor
           typ::tag TypeKind::GenericStructInstance == lor
           typ::tag TypeKind::GenericUnionBase      == lor
           typ::tag TypeKind::GenericUnionInstance  == lor if {
        true
    } else {
        false
    }

}

fn Type.assign_generics(
    Token: token
    *Type: typ_p
    *Stack<*Type>: generics
    *Stack<*Type>: assignments
    *Map<*Type>: types 
) -> [*Type] {

    typ_p @ as [typ]

    typ::tag TypeKind::Placeholder == if {
        typ_p generics Stack.find Opt.is_none if {
            token::loc Loc.puts
            ": Unrecognized generic: " puts typ_p Type.name putlns
            1 exit
        }

        typ_p generics Stack.find Opt.unwrap
        assignments Stack.slice Arr.get
    } else typ::tag TypeKind::GenericStructBase ==
           typ::tag TypeKind::GenericUnionBase  == lor if {

        typ::tag TypeKind::GenericStructBase == if {
            typ::type::GenericStructBase::base::name
            typ::type::GenericStructBase::base::members
        } else typ::tag TypeKind::GenericUnionBase == if  {
            typ::type::GenericUnionBase::base::name
            typ::type::GenericUnionBase::base::members
        } else {
            typ::type::GenericStructBase::base::name
            typ::type::GenericStructBase::base::members
            "Unreachable state in Type.assign_generics" putlns
            1 exit 
        } as [base_name members]
        members @ split as [idents member_types] {
            idents Stack.slice member_types Stack.slice 
        } as [idents member_types]

        Map.new::<*Type> as [resolved_members]

        0 while dup idents::size < {
            as [i]
            i idents Arr.get
            token i member_types Arr.get generics assignments types Type.assign_generics
            resolved_members Map.insert drop
            i 1 +
        } drop

        Stack.new::<u8> as [name_builder]
        0 while dup base_name::size < {
            as [i]

            i base_name split cast(Arr) Arr.get name_builder Stack.push
            i 1 +
        } drop

        0 "<" split cast(Arr) Arr.get name_builder Stack.push

        0 while dup assignments Stack.len < {
            as [i]
            
            i 0 != if {
                0 " " split cast(Arr) Arr.get name_builder Stack.push
            }

            i assignments Stack.slice Arr.get Type.name split cast(Arr) as [typ_name]
            0 while dup typ_name::size < {
                as [j]
                j typ_name Arr.get name_builder Stack.push
                j 1 +
            } drop
            i 1 +
        } drop
        
        0 ">" split cast(Arr) Arr.get name_builder Stack.push

        name_builder Stack.len malloc::<u8> split cast(Str) as [name]
        name_builder Stack.slice split name::data memcpy
        name_builder Stack.destroy

        name types Map.contains if {
            name types Map.get Opt.unwrap
            resolved_members Map.destroy
            name split cast(Arr) free
        } else {
            name resolved_members typ_p
            typ::tag TypeKind::GenericStructBase == if {
                Type.ResolvedStruct
            } else typ::tag TypeKind::GenericUnionBase == if {
                Type.ResolvedUnion
            } else {
                "Unreachable state when buiding resolved Union/Struct" putlns
                1 exit
                Type.ResolvedStruct
            } as [new_t]

            name new_t types Map.insert drop
            new_t
        }

    } else typ::tag TypeKind::Pointer == if {
        token typ::type::Pointer::inner generics assignments types Type.assign_generics
        Type.Pointer as [t]

        t Type.name as [name] {
            name types Map.contains if {
                name types Map.get Opt.unwrap
                name split cast(Arr) free 
            } else {
                name t types Map.insert drop
                t
            }
        }

    } else typ::tag TypeKind::U64 == 
           typ::tag TypeKind::U8 == lor
           typ::tag TypeKind::Bool == lor
           typ::tag TypeKind::Enum == lor
           typ::tag TypeKind::Struct == lor
           typ::tag TypeKind::ResolvedStruct == lor
           typ::tag TypeKind::Union == lor
           typ::tag TypeKind::ResolvedUnion == lor if {
        typ_p
    } else {
        "Assigning generics to " puts typ::tag TypeKind.puts " isn't implemented yet" putlns
        1 exit
        typ_p
    }

}