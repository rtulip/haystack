include "vec.hay"
include "selfhost/src/error.hay"
include "selfhost/src/utils/sets.hay"
include "selfhost/src/lex/token.hay"
include "selfhost/src/ast/member/untyped.hay"
include "selfhost/src/ast/stmt/stmt.hay"
include "selfhost/src/ast/visibility.hay"
include "selfhost/src/types/record/record_kind.hay"

struct Stmt:
struct Parser {
    *Set      : visited
    Vec<Token>: tokens
    Vec<Stmt> : stmts
    

impl:

    inline fn Parser.new(Vec<Token>: tokens *Set: visited) -> [Parser] {
        visited
        tokens Vec.reverse
        Vec.new::<Stmt>
        cast(Parser)
    }

    fn Parser.parse(Parser: mut self) -> [Result<Vec<Stmt> HayError>] {

        while &self Parser.is_at_end lnot {

            *self Parser.declaration as [result]
            &result Result.is_ok if {
                result Result.unwrap as [mut stmts]
                *stmts *self::stmts Vec.append
                &stmts Vec.delete 
            } else {
                result return
            }

        }

        Vec.new::<Stmt> Result.Ok::<Vec<Stmt> HayError>
    }

    inline fn Parser.is_at_end(&Parser: self) -> [bool] {
        self::tokens Vec.last Opt.unwrap as [tok]
        TokenKind.EoF as [eof] &eof tok::kind TokenKind.equals
    }

    inline fn Parser.peek(&Parser: self) -> [&Token] {
        self::tokens Vec.last Opt.unwrap 
    }

    inline fn Parser.check(TokenKind: kind &Parser: self) -> [bool] {
        self Parser.is_at_end if {
            false
        } else {
            self Parser.peek as [tok]
            tok::kind &kind TokenKind.equals
        }
    }

    inline fn Parser.matches(TokenKind: kind *Parser: self) -> [Result<Token Token>] {
        kind self Parser.check if {
            self::tokens Vec.pop Opt.unwrap Result.Ok::<Token Token>
        } else {
            self::tokens Vec.last Opt.unwrap @ Result.Err::<Token Token>
        }
    }

    fn Parser.declaration(*Parser: self) -> [Result<Vec<Stmt> HayError>] {
        
        self::tokens Vec.pop Opt.unwrap as [token]
        Keyword::Inline TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            "todo: Parser.inline" putlns
            1 exit
            Vec.new::<Stmt> Result.Ok::<Vec<Stmt> HayError> 
        } else Keyword::Function TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token Vec.new::<FnTag> Opt.None::<&Token> self Parser.function
        } else Keyword::Struct TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token self Parser.record
        } else Keyword::Union TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token self Parser.record
        } else Keyword::Enum TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token self Parser.enum
        } else Keyword::Include TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token self Parser.include
        } else Keyword::Var TokenKind.Keyword as [kw] { &kw &token::kind TokenKind.equals } if {
            token self Parser.var as [result] {
                &result Result.is_ok if {
                    Vec.new::<Stmt> as [mut v]
                    result Result.unwrap token cast(VarStmt) Stmt.Var *v Vec.push
                    v Result.Ok::<Vec<Stmt> HayError>
                } else {
                    result Result.unwrap_err Result.Err::<Vec<Stmt> HayError>
                }
            }
        } else {
            "Unexpected top level token: " HString.new
            &token::kind TokenKind.format
            token::loc
            HayError.new Result.Err::<Vec<Stmt> HayError>
        }
    }

    fn Parser.enum(Token: start *Parser: self) -> [Result<Vec<Stmt> HayError>] {

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap
            } else {
                match Result.unwrap_err as [t]
                "Expected an identifier after " HString.new
                Keyword::Enum Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        } as [name]

        Marker::LeftBrace TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftBrace Marker.format
                " after enum name, but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        }

        Vec.new::<Token> as [mut variants]

        while TokenKind.ident_default self Parser.matches dup Result.take_is_ok {
            Result.unwrap *variants Vec.push
        } drop

        Marker::RightBrace TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightBrace Marker.format
                " after variants, but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        }

        &variants Vec.is_empty if {
            "Enumerations must have at least one variant." HString.new
            name::loc
            HayError.new Result.Err::<Vec<Stmt> HayError> return
        }

        Vec.new::<Stmt> as [mut stmts]
        start name variants cast(EnumStmt) Stmt.Enum *stmts Vec.push
        stmts Result.Ok::<Vec<Stmt> HayError>

    }

    fn Parser.include(Token: start *Parser: self) -> [Result<Vec<Stmt> HayError>] {
        TokenKind.string_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap as [tok]
                &tok Token.string as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
                    }
                }
            } else {
                match Result.unwrap_err as [t]
                "Expected Str after include statement. Found " HString.new
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        } as [to_include] {
            "./src/libs/" HString.new
            &to_include  HString.as_str HString.push_str

            "./" HString.new to_include HString.format
        } as [libs_path to_include]
        
        &to_include HString.as_str File.exists if {
            self::visited @ &to_include Stmt.from_file
        } else &libs_path HString.as_str File.exists if {
            self::visited @ &libs_path Stmt.from_file
        } else {
            "Failed to find file to include: " HString.new
            &to_include HString.as_str HString.push_str
            start::loc
            HayError.new Result.Err::<Vec<Stmt> HayError>
        }
    }

    fn Parser.inline_function(Token: start Opt<&Token>: impl_on *Parser: self) -> [Result<Vec<Stmt> HayError>] {
        Keyword::Function TokenKind.Keyword self Parser.matches as [match]
        &match Result.is_ok if {
            match Result.unwrap
        } else {
            match Result.unwrap_err as [t]
            "Expected keyword " HString.new
            Keyword::Function Keyword.format
            "after " HString.push_str
            Keyword::Include Keyword.format
            ", but found " HString.push_str
            &t::kind TokenKind.format
            " instead." HString.push_str
            t::loc
            HayError.new Result.Err::<Vec<Stmt> HayError> return
        }

        Vec.new::<FnTag> as [mut tags]
        FnTag::Inline *tags Vec.push
        tags
        impl_on
        self Parser.function
    }

    fn Parser.function(
        Token: start 
        Vec<FnTag>: mut tags 
        Opt<&Token>: impl_on
        *Parser: self 
    ) -> [Result<Vec<Stmt> HayError>] {

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "expected function name after " HString.new
                Keyword::Function Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        } as [name]

        // todo: check for +/-

        Operator.LessThan TokenKind.Operator self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap as [open]
                &open self Parser.unnamed_args_list as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap Opt.Some
                    } else {
                        result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
                    }
                }

                Operator.GreaterThan TokenKind.Operator self Parser.matches as [result] {
                    &result Result.is_err if {
                        drop result Result.unwrap_err as [t]
                        "Expected " HString.new
                        Operator.GreaterThan Operator.take_format
                        " after function annotations, but found " HString.push_str
                        &t::kind TokenKind.format
                        " instead." HString.push_str
                        t::loc
                        HayError.new Result.Err::<Vec<Stmt> HayError> return
                    }
                }
            } else {
                Opt.None::<Vec<UntypedArg>>
            }
        } as [annotations]

        Marker::LeftParen TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftParen Marker.format
                " after function name, but found " HString.push_str
                &t::kind TokenKind.format 
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        } as [open]

        &open self Parser.args_list as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
            }
        } as [inputs]

        Marker::RightParen TokenKind.Marker self Parser.matches as [match]{
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightParen Marker.format
                " after inputs, but found " HString.push_str
                &t::kind TokenKind.format 
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        }

        Marker::Arrow TokenKind.Marker self Parser.matches Result.take_is_ok if {
            Marker::LeftBracket TokenKind.Marker self Parser.matches as [match]
            &match Result.is_ok if {
                match Result.unwrap
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftBracket Marker.format
                " after " HString.push_str
                Marker::Arrow Marker.format 
                ", but found " HString.push_str
                &t::kind TokenKind.format 
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            } as [tok]

            &tok self Parser.unnamed_args_list as [result]{
                &result Result.is_ok if {
                    result Result.unwrap
                } else {
                    result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
                }
            } as [outputs]

            Marker::RightBracket TokenKind.Marker self Parser.matches as [close] {
                &close Result.is_err if {
                    match Result.unwrap_err as [t]
                    "Expected " HString.new
                    Marker::RightBracket Marker.format
                    " after return types, but found " HString.push_str
                    &t::kind TokenKind.format 
                    " instead." HString.push_str
                    t::loc
                    HayError.new Result.Err::<Vec<Stmt> HayError> return
                }
            }

            &outputs Vec.is_empty if {
                "Expected a non-empty return list." HString.new
                tok::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }

            outputs
        } else {
            Vec.new::<UntypedArg>
        } as [outputs]
        
        self Parser.block as [result]{
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
            }
        } as [body]

        Vec.new::<Stmt> as [mut stmts]
        start
        name
        inputs
        outputs
        annotations
        body
        tags
        impl_on Token.opt_clone
        cast(FunctionStmt) Stmt.Function *stmts Vec.push

        stmts Result.Ok::<Vec<Stmt> HayError> 

    }

    fn Parser.expression(*Parser: self) -> [Result<Expr HayError>] {
        self::tokens Vec.pop Opt.unwrap as [token]

        token::kind::tag TokenKindTag::Ident == if {
            
            &token Token.clone as [mut new_token]
            Vec.new::<Token> as [mut inners]
            while Marker::DoubleColon TokenKind.Marker self Parser.matches as [match] {
                match
                &match Result.is_ok
            }
            {
                Result.unwrap as [dc]
                self::tokens Vec.pop Opt.unwrap as [next]
                next::kind::tag TokenKindTag::Ident == if {
                    "" HString.new
                    &new_token::lexeme HString.as_str HString.push_str
                    &dc::lexeme        HString.as_str HString.push_str
                    &next::lexeme      HString.as_str HString.push_str
                    as [new_lexeme]
                    
                    &new_lexeme HString.clone TokenKind.Ident
                    new_lexeme
                    new_token::loc::file
                    new_token::loc::line
                    new_token::loc::span::start
                    next::loc::span::end
                    Token.new *new_token !

                    next *inners Vec.push

                } else next::kind::tag TokenKindTag::Marker == if {
                    "Marker after Ident isn't implemented yet" putlns
                    1 exit
                } else next::kind::tag TokenKindTag::Operator == if {
                    
                    &next Token.operator Result.unwrap Operator.LessThan Operator.take_equals if {

                        &inners Vec.is_empty lnot if {
                            "Cannot provide annotations within this context" HString.new
                            next::loc
                            HayError.new Result.Err::<Expr HayError> return
                        }

                        &next self Parser.unnamed_args_list as [result] {
                            &result Result.is_ok if {
                                result Result.unwrap
                            } else {
                                result Result.unwrap_err Result.Err::<Expr HayError> return
                            }
                        } as [annotations]

                        Operator.GreaterThan TokenKind.Operator self Parser.matches as [match] {
                            &match Result.is_ok if {
                                match Result.unwrap
                            } else {
                                match Result.unwrap_err as [t]
                                "Expected " HString.new
                                Operator.GreaterThan Operator.take_format
                                " after call annotations, but found " HString.push_str
                                &t::kind TokenKind.format 
                                " instead." HString.push_str
                                t::loc
                                HayError.new Result.Err::<Expr HayError> return
                            }
                        } as [close]

                        &annotations Vec.is_empty if {
                            "Expected a non-zero number of annotations." HString.new
                            next::loc
                            HayError.new Result.Err::<Expr HayError> return
                        }

                        "<" HString.new
                        &token::lexeme HString.as_str HString.push_str
                        0 while dup &annotations Vec.len 1 - < {
                            as [i]
                            i &annotations Vec.get Opt.unwrap as [arg]
                            arg::token::lexeme HString.as_str HString.push_str
                            ' ' HString.push
                            i 1 +
                        } drop
                        &annotations Vec.last Opt.unwrap as [arg] {
                            arg::token::lexeme HString.as_str HString.push_str
                            '>' HString.push
                        } 
                        as [lexeme]

                        &lexeme HString.clone TokenKind.Ident
                        lexeme
                        new_token::loc::file
                        new_token::loc::line
                        new_token::loc::span::start
                        close::loc::span::end
                        Token.new token annotations cast(AnnotatedCallExpr)
                        Expr.AnnotatedCall Result.Ok::<Expr HayError> return
                        
                    } else {
                        &inners Vec.is_empty if {
                            "Expected an identifier or " HString.new
                            Operator.LessThan Operator.take_format
                            " after " HString.push_str
                            Marker::DoubleColon Marker.format
                            ", but found " HString.push_str
                            &next::kind TokenKind.format
                            "instead." HString.push_str
                            next::loc
                            HayError.new Result.Err::<Expr HayError> return
                        } else {
                            "Expected an identifier after " HString.new
                            Marker::DoubleColon Marker.format
                            ", but found " HString.push_str
                            &next::kind TokenKind.format
                            " instead." HString.push_str
                            next::loc
                            HayError.new Result.Err::<Expr HayError> return
                        }
                    }
                } else next::kind::tag TokenKindTag::Keyword == if {
                    "Keyword after Ident isn't implemented yet" putlns
                    1 exit
                } else next::kind::tag TokenKindTag::Literal == if {
                    "Literal after Ident isn't implemented yet" putlns
                    1 exit
                } else next::kind::tag TokenKindTag::Syscall == if {
                    "Syscall after Ident isn't implemented yet" putlns
                    1 exit
                } else next::kind::tag TokenKindTag::Type == if {
                    "Type after Ident isn't implemented yet" putlns
                    1 exit
                } else next::kind::tag TokenKindTag::EoF == if {
                    "EoF after Ident isn't implemented yet" putlns
                    1 exit
                } else {
                    "Unreachabe after Ident" putlns
                    1 exit
                }
            } drop

            &inners Vec.is_empty if {
                token cast(IdentExpr) Expr.Ident Result.Ok::<Expr HayError>
            } else {
                new_token token inners cast(AccessorExpr) Expr.Accessor Result.Ok::<Expr HayError>
            }

        } else token::kind::tag TokenKindTag::Marker == if {
            "TokenKind Marker is not implemented yet" putlns
            &token Token.putln
            1 exit
            token cast(IdentExpr) Expr.Ident Result.Ok::<Expr HayError>
        } else token::kind::tag TokenKindTag::Operator == if {
            
            &token Token.operator Result.unwrap as [op]
            op::tag OperatorTag::Unary == if {
                &op Operator.unary Opt.unwrap as [unary_tok]

                unary_tok Token.clone self Parser.unary
            } else {
                
                &op Operator.clone
                token
                cast(OperatorExpr) Expr.Operator Result.Ok::<Expr HayError>
            }

        } else token::kind::tag TokenKindTag::Keyword == if {
            &token Token.keyword Result.unwrap as [kw]

            kw Keyword::Cast == if {
                token self Parser.cast
            } else kw Keyword::SizeOf == if {
                token self Parser.size_of
            } else kw Keyword::While == if {
                token self Parser.while
            } else kw Keyword::As == if {
                token self Parser.as
            } else kw Keyword::If == if {
                token self Parser.if 
            } else kw Keyword::Var == if {
                token self Parser.var as [result]
                &result Result.is_ok if {
                    result Result.unwrap Expr.Var Result.Ok::<Expr HayError>
                } else {
                    result Result.unwrap_err Result.Err::<Expr HayError>
                }
            } else {
                "Not sure how to parse expression from " HString.new
                &token::kind TokenKind.format
                token::loc
                HayError.new Result.Err::<Expr HayError>
            }
        } else token::kind::tag TokenKindTag::Literal == if {
            &token Token.literal Result.unwrap
            token
            cast(LiteralExpr) Expr.Literal Result.Ok::<Expr HayError>
        } else token::kind::tag TokenKindTag::Syscall == if {
            &token::kind TokenKind.syscall Opt.unwrap
            token
            cast(SyscallExpr) Expr.Syscall Result.Ok::<Expr HayError>
        } else token::kind::tag TokenKindTag::Type == if {
            "TokenKind Type is not implemented yet" putlns
            1 exit
            token cast(IdentExpr) Expr.Ident Result.Ok::<Expr HayError>
        } else token::kind::tag TokenKindTag::EoF == if {
            "TokenKind EoF is not implemented yet" putlns
            1 exit
            token cast(IdentExpr) Expr.Ident Result.Ok::<Expr HayError>
        } else {
            "Parser.expression unreachable" putlns
            1 exit
            token cast(IdentExpr) Expr.Ident Result.Ok::<Expr HayError>
        }
    }

    fn Parser.var(Token: token *Parser: self) -> [Result<VarExpr HayError>] {
        self Parser.parse_type as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<VarExpr HayError> return
            } as [option]
            &option Opt.is_some if {
                option Opt.unwrap
            } else {
                self Parser.peek as [peek]
                "Expected a type after " HString.new
                Keyword::Var Keyword.format
                ", but found " HString.push_str
                peek::kind TokenKind.format
                " instead." HString.push_str
                token::loc
                HayError.new Result.Err::<VarExpr HayError> return
            }
        } as [type]

        Marker::Colon TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::Colon Marker.format
                " after type, but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<VarExpr HayError> return
            }
        }   

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap
            } else {
                match Result.unwrap_err as [t]
                "Expected an identifier after " HString.new
                &type::kind TokenKind.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<VarExpr HayError> return
            }
        } as [ident]

        token type ident cast(VarExpr) Result.Ok::<VarExpr HayError>
    }

    fn Parser.if(Token: token *Parser: self) -> [Result<Expr HayError>] {

        self Parser.block as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            }
        } as [then]

        Vec.new::<ElseIfExpr> Opt.None::<Vec<Expr>> as [mut otherwise mut finally]

        while Keyword::Else TokenKind.Keyword self Parser.matches as [match] {
            match
            &match Result.is_ok
            &finally Opt.is_none land
        }
        {
            Result.unwrap as [else_tok]
            self Parser.peek as [peek]

            Marker::LeftBrace TokenKind.Marker as [marker] { &marker peek::kind  TokenKind.equals } if {
                self Parser.block as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap Opt.Some *finally !
                    } else {
                        result Result.unwrap_err Result.Err::<Expr HayError> return
                    }
                }
            } else {

                self Parser.else_if_condition as [result]{
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Expr HayError> return
                    }
                } as [cond]

                self Parser.block as [result]{
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Expr HayError> return
                    }
                } as [body]

                else_tok cond body cast(ElseIfExpr) *otherwise Vec.push
            }
        } drop

        token then otherwise finally cast(IfExpr) Expr.If Result.Ok::<Expr HayError>

    }

    fn Parser.else_if_condition(*Parser: self) -> [Result<Vec<Expr> HayError>] {
        Vec.new::<Expr> as [mut cond]
        while self Parser.is_at_end lnot
            self Parser.peek as [peek] {
                Keyword::If TokenKind.Keyword as [kw] { &kw peek::kind TokenKind.equals } lnot    
            }
            land
        {
            self Parser.expression as [result] {
                &result Result.is_ok if {
                    result Result.unwrap *cond Vec.push
                } else {
                    result Result.unwrap_err Result.Err::<Vec<Expr> HayError> return
                }
            }
        }

        Keyword::If TokenKind.Keyword self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Keyword::If Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Expr> HayError> return
            }
        }

        cond Result.Ok::<Vec<Expr> HayError>
    }

    fn Parser.maybe_mut_ident(*Parser: self) -> [Result<Opt<IdentArg> HayError>]{
        Keyword::Mut TokenKind.Keyword self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap Opt.Some
            } else {
                Opt.None::<Token>
            }
        } as [mutable]

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap mutable cast(IdentArg) Opt.Some
                Result.Ok::<Opt<IdentArg> HayError>
            } else {
                &mutable Opt.is_some if {
                    mutable Opt.unwrap as [mut_tok]
                    match Result.unwrap_err as [t]
                    "Expected an identifier after keyword" HString.new
                    &mut_tok::kind TokenKind.format
                    ", but found " HString.push_str
                    &t::kind TokenKind.format
                    " instead." HString.push_str
                    mut_tok::loc
                    HayError.new Result.Err::<Opt<IdentArg> HayError>
                } else {
                    Opt.None::<IdentArg> Result.Ok::<Opt<IdentArg> HayError> 
                }
            }
        }
    }

    fn Parser.maybe_mut_ident_list(*Parser: self) -> [Result<Vec<IdentArg> HayError>] {
        Vec.new::<IdentArg> as [mut args]
        while self Parser.maybe_mut_ident as [result] {
            &result Result.is_ok if {
                result Result.unwrap as [opt]
                opt &opt Opt.is_some 
            } else {
                result Result.unwrap_err Result.Err::<Vec<IdentArg> HayError> return
            }
        }
        {
            Opt.unwrap *args Vec.push
        } drop

        args Result.Ok::<Vec<IdentArg> HayError>
    }

    fn Parser.as(Token: token *Parser: self) -> [Result<Expr HayError>] {

        Marker::LeftBracket TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftBracket Marker.format
                " after " HString.push_str
                Keyword::As Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        }

        self Parser.maybe_mut_ident_list as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            }
        } as [idents]

        Marker::RightBracket TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightBracket Marker.format
                " after " HString.push_str
                Keyword::As Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        }

        Marker::LeftBrace TokenKind.Marker self Parser.check if {
            self Parser.block as [result] {
                &result Result.is_ok if {
                    result Result.unwrap Opt.Some
                } else {
                    result Result.unwrap_err Result.Err::<Expr HayError> return
                }
            }
        } else {
            Opt.None::<Vec<Expr>>
        } as [block]

        token idents block cast(AsExpr) Expr.As Result.Ok::<Expr HayError>

    }

    fn Parser.while(Token: token *Parser: self) -> [Result<Expr HayError>] {

        Vec.new::<Expr> as [mut cond]
        while self Parser.is_at_end lnot
            Marker::LeftBrace TokenKind.Marker self Parser.check lnot
            land
        {
            self Parser.expression as [result]
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result return
            }
            *cond Vec.push
        }

        self Parser.block as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            }
        } as [body]

        token cond body cast(WhileExpr) Expr.While Result.Ok::<Expr HayError>

    }

    fn Parser.unary(Token: op *Parser: self) -> [Result<Expr HayError>] {
        self Parser.expression as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result return
            }
        } as [expr]

        malloc_obj::<Expr> as [e]
        expr e !

        &op Token.operator as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            }
        }
        op
        cast(OperatorExpr) 
        e
        cast(UnaryExpr) Expr.Unary Result.Ok::<Expr HayError>

    }

    fn Parser.size_of(Token: token *Parser: self) -> [Result<Expr HayError>] {
        Marker::LeftParen TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftParen Marker.format
                " after " HString.push_str
                Keyword::SizeOf Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [open]

        self Parser.parse_type as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            } as [option]
            &option Opt.is_some if {
                option Opt.unwrap
            } else {
                self Parser.peek as [t]
                "Expected type identifier, but found " HString.new
                t::kind TokenKind.format
                " instead." HString.push_str
                open::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [type]

        Marker::RightParen TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightParen Marker.format
                " after type identifier, but found" HString.push_str
                &type::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [close]

        token type cast(SizeOfExpr) Expr.SizeOf Result.Ok::<Expr HayError>
    }

    fn Parser.cast(Token: cast_tok *Parser: self) -> [Result<Expr HayError>] {

        Marker::LeftParen TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftParen Marker.format
                " after " HString.push_str
                Keyword::Cast Keyword.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [open]

        self Parser.parse_type as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Expr HayError> return
            } as [option]
            &option Opt.is_some if {
                option Opt.unwrap
            } else {
                self Parser.peek as [t]
                "Expected type after " HString.new
                Keyword::Cast Keyword.format
                ", but found " HString.push_str
                t::kind TokenKind.format
                " instead." HString.push_str
                open::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [type]

        Marker::RightParen TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightParen Marker.format
                " after " HString.push_str
                &type::kind TokenKind.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                t::loc
                HayError.new Result.Err::<Expr HayError> return
            }
        } as [close]

        "" HString.new
        &cast_tok::lexeme HString.as_str HString.push_str
        &open::lexeme     HString.as_str HString.push_str
        &type::lexeme     HString.as_str HString.push_str
        &close::lexeme    HString.as_str HString.push_str
        as [new_lexeme]

        Keyword::Cast TokenKind.Keyword
        new_lexeme
        cast_tok::loc::file
        cast_tok::loc::line
        cast_tok::loc::span::start
        close::loc::span::end
        Token.new
        type
        cast(CastExpr) Expr.Cast Result.Ok::<Expr HayError>

    }

    fn Parser.block(*Parser: self) -> [Result<Vec<Expr> HayError>] {

        Marker::LeftBrace TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::LeftBrace Marker.format
                " at start of block, but found " HString.push_str
                &t::kind TokenKind.format 
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Expr> HayError> return
            }
        }

        Vec.new::<Expr> as [mut exprs]

        while self Parser.is_at_end lnot
            Marker::RightBrace TokenKind.Marker self Parser.check lnot
            land
        {
            self Parser.expression as [result] {
                &result Result.is_ok if {
                    result Result.unwrap
                } else {
                    result Result.unwrap_err Result.Err::<Vec<Expr> HayError> return
                }
            } 
            *exprs Vec.push
        }

        Marker::RightBrace TokenKind.Marker self Parser.matches as [match] {
            &match Result.is_err if {
                match Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightBrace Marker.format
                " at end of block, but found " HString.push_str
                &t::kind TokenKind.format 
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Expr> HayError> return
            }
        }
        
        exprs Result.Ok::<Vec<Expr> HayError>

    }

    fn Parser.parse_type(*Parser: self) -> [Result<Opt<Token> HayError>] {
        0 cast(*Token) Operator.Unary TokenKind.Operator      self Parser.matches as [unary_match]                     
        &unary_match Result.is_ok if {
            unary_match Result.unwrap as [op_tok]
            
            &op_tok Token.unary_operator as [result] {
                &result Result.is_err if {
                    result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                } else {
                    result Result.unwrap
                }
            } as [op]
            self Parser.parse_type as [result] {
                &result Result.is_err if {
                    result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                } else {
                    result Result.unwrap
                }
            } as [maybe_type]
            &maybe_type Opt.is_some if {
                maybe_type Opt.unwrap as [type]
                op Operator.Ampersand Operator.take_equals if {
                    malloc_obj::<TypeToken> as [inner]
                    &type Token.type as [result] {
                        &result Result.is_err if {
                            result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                        } else {
                            result Result.unwrap
                        }
                    }
                    inner !
                    inner false TypeToken.Pointer TokenKind.Type
                    "&" HString.new
                    &type::lexeme HString.clone HString.format
                    type::loc
                    cast(Token) Opt.Some Result.Ok::<Opt<Token> HayError>
                } else op Operator.Star Operator.take_equals if {
                    malloc_obj::<TypeToken> as [inner]
                    &type Token.type as [result] {
                        &result Result.is_err if {
                            result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                        } else {
                            result Result.unwrap
                        }
                    }
                    inner !
                    inner true TypeToken.Pointer TokenKind.Type
                    "*" HString.new
                    &type::lexeme HString.clone HString.format
                    type::loc
                    cast(Token) Opt.Some Result.Ok::<Opt<Token> HayError>
                } else {
                    &op::tag OperatorTag.putln
                    
                    "Unary "            HString.new
                    &op                 Operator.format
                    " is not supported" HString.push_str
                    op_tok::loc
                    HayError.new
                    "" HString.new
                    &op_tok Token.format
                    HayError.with_hint 
                    Result.Err::<Opt<Token> HayError>
                }
            } else {
                "Internal Error: Unary op with no type" putlns
                &op_tok Token.putln
                1 exit
                Opt.None::<Token> Result.Ok::<Opt<Token> HayError>
            }
        } else TokenKind.ident_default self Parser.matches as [ident_match]{
            ident_match
            &ident_match Result.is_ok
        } if {
            Result.unwrap as [ident]
            Operator.LessThan TokenKind.Operator self Parser.matches 
            Result.take_is_ok if {
                Vec.new::<TypeToken> as [mut inner]

                while self Parser.parse_type as [result] {
                    &result Result.is_err if {
                        result return
                    } else {
                        result Result.unwrap as [maybe_tok]
                        maybe_tok
                        &maybe_tok Opt.is_some
                    }
                }
                {
                    Opt.unwrap as [t] {
                        &t Token.type as [result] {
                            &result Result.is_err if {
                                result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                            } else {
                                result Result.unwrap *inner Vec.push
                            }
                        }
                        // todo &t Token.delete
                    }
                } drop

                Operator.GreaterThan TokenKind.Operator self 
                Parser.matches as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err as [t]
                        "Expected "                          HString.new
                        Operator.GreaterThan                 Operator.take_format
                        " after type parameters, but found " HString.push_str
                        &t::kind                             TokenKind.format
                        t::loc
                        HayError.new Result.Err::<Opt<Token> HayError> return
                    }
                } as [close]

                &ident Token.ident as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                    }
                }
                inner TypeToken.Parameterized TokenKind.Type as [kind]
                "" HString.new
                &kind TokenKind.format as [lexeme]

                kind
                lexeme
                &ident::loc::file HString.clone
                ident::loc::line
                ident::loc::span::start
                close::loc::span::end
                Token.new
                //todo: &ident Token.delete
            } else {
                &ident::lexeme HString.clone
                TypeToken.Base TokenKind.Type
                &ident::lexeme HString.clone
                ident::loc
                cast(Token)
            } as [type]

            Marker::LeftBracket TokenKind.Marker self Parser.matches 
            Result.take_is_ok if {

                TokenKind.u64_default self Parser.matches as [match]
                &match Result.is_ok if {
                    match Result.unwrap as [n]
                    &n Token.u64 as [result] {
                        &result Result.is_ok if {
                            result Result.unwrap 
                        } else {
                            result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                        }
                    }
                } else {
                    match Result.unwrap_err as [t]
                    "Expected array size after " HString.new
                    Marker::LeftBracket          Marker.format
                    ", but found "               HString.push_str
                    &t::kind                     TokenKind.format
                    t::loc
                    HayError.new Result.Err::<Opt<Token> HayError> return
                } as [n]

                Marker::RightBracket TokenKind.Marker self Parser.matches
                as [match] {
                    &match Result.is_ok if {
                        match Result.unwrap
                    } else {
                        match Result.unwrap_err as [t]
                        "Expected "                    HString.new
                        Marker::RightBracket           Marker.format 
                        "after array size, but found " HString.push_str
                        &t::kind                       TokenKind.format
                        t::loc
                        HayError.new Result.Err::<Opt<Token> HayError> return
                    }
                } as [close]

                malloc_obj::<TypeToken> as [box]
                &type Token.type as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Opt<Token> HayError> return
                    }
                } 
                box !
                
                box n TypeToken.Array TokenKind.Type as [kind]
                "" HString.new
                &kind TokenKind.format
                kind 

                swap
                &type::loc::file HString.clone
                type::loc::line
                type::loc::span::start
                close::loc::span::end
                Token.new Opt.Some Result.Ok::<Opt<Token> HayError>

            } else {
                type Opt.Some Result.Ok::<Opt<Token> HayError>
            }

        } else drop Operator.Ampersand TokenKind.Operator self Parser.matches as [ampersand_match] {
          ampersand_match  
          &ampersand_match Result.is_ok
        } if {
            Result.unwrap as [token]
            "Expected type after "  HString.new
            Operator.Star           Operator.take_format
            ", but found "          HString.push_str
            &token::kind            TokenKind.format
            " instead."             HString.push_str
            token::loc
            HayError.new Result.Err::<Opt<Token> HayError>
        } else drop Operator.Star TokenKind.Operator self Parser.matches as [star_match] {
          star_match  
          &star_match Result.is_ok
        } if {
            Result.unwrap as [token]
            "Expected type after "  HString.new
            Operator.Star           Operator.take_format
            ", but found "          HString.push_str
            &token::kind            TokenKind.format
            " instead."             HString.push_str
            token::loc
            HayError.new Result.Err::<Opt<Token> HayError>
        } else {
            drop Opt.None::<Token> Result.Ok::<Opt<Token> HayError>
        }

    }

    fn Parser.parse_arg(*Parser: self) -> [Result<Opt<UntypedArg> HayError>] {
        self Parser.parse_type as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Opt<UntypedArg> HayError> return
            }
        } as [maybe_token] {
            &maybe_token Opt.is_some if {
                maybe_token Opt.unwrap as [token]
                Marker::Colon TokenKind.Marker self Parser.matches as [match] {
                    &match Result.is_ok 
                }

                if  {
                    Keyword::Mut TokenKind.Keyword self Parser.matches Result.ok as [mutable]
                    TokenKind.ident_default self Parser.matches as [result] {
                        &result Result.is_ok if {
                            result Result.unwrap as [ident]
                            token
                            mutable
                            ident Opt.Some
                            cast(UntypedArg) Opt.Some Result.Ok::<Opt<UntypedArg> HayError>
                        } else {
                            result Result.unwrap_err as [t]
                            "Expected an identifier after " HString.new
                            Marker::Colon Marker.format
                            ", but found " HString.push_str
                            &t::kind TokenKind.format
                            " instead." HString.push_str
                            t::loc
                            HayError.new Result.Err::<Opt<UntypedArg> HayError>
                        }
                    }
                } else {
                    token
                    Opt.None::<Token>
                    Opt.None::<Token>
                    cast(UntypedArg) Opt.Some Result.Ok::<Opt<UntypedArg> HayError>
                }

            } else {
                Opt.None::<UntypedArg> Result.Ok::<Opt<UntypedArg> HayError>
            }
        }
    }

    fn Parser.args_list(&Token: token *Parser: self) -> [Result<Vec<UntypedArg> HayError>] {
        Vec.new::<UntypedArg> as [mut args]
        while self Parser.parse_arg as [result] {
            &result Result.is_ok if {
                result Result.unwrap as [maybe_arg]
                &maybe_arg Opt.is_some if {
                    maybe_arg
                    true
                } else {
                    Opt.None::<UntypedArg>
                    false
                }
            } else {
                result Result.unwrap_err Result.Err::<Vec<UntypedArg> HayError> return
            }
        }
        {
            Opt.unwrap *args Vec.push
        } drop

        true true
        0 while dup &args Vec.len < {
            as [all none i]

            i &args Vec.get Opt.unwrap as [arg]
            arg::ident Opt.is_some all  land
            arg::ident Opt.is_none none land

            i 1 +
        } drop as [all none]
        
        all none lor lnot if {
            "Either all arguments or no arguments in args list must have an identifier." HString.new
            token::loc @ 
            HayError.new Result.Err::<Vec<UntypedArg> HayError> 
        } else {
            args Result.Ok::<Vec<UntypedArg> HayError>
        }

    }

    fn Parser.unnamed_args_list(&Token: token *Parser: self) -> [Result<Vec<UntypedArg> HayError>] {

        token self Parser.args_list as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Vec<UntypedArg> HayError> return
            }
        } as [args]

        0 while dup &args Vec.len < {
            as [i]
            i &args Vec.get Opt.unwrap as [arg] 
            arg::ident Opt.is_some if {
                "Not all arguments are unnamed" HString.new
                arg::token::loc @
                HayError.new Result.Err::<Vec<UntypedArg> HayError> return 
            }
            i 1 +
        } drop 

        args Result.Ok::<Vec<UntypedArg> HayError>

    }

    fn Parser.member(
        &Token: type
        &RecordKind: kind
        *Parser: self
    ) -> [Result<Opt<UntypedMember> HayError>] {
        Keyword::Pub TokenKind.Keyword self Parser.matches as [match] {
            &match Result.is_ok if {
                Visibility::Public match Result.unwrap Opt.Some
            } else {
                Visibility::Private Opt.None::<Token>
            }
        } as [vis vis_tok]

        vis Visibility::Public ==
        kind @ RecordKind::Union == land if {
            vis_tok Opt.unwrap as [tok]
            "Unexpected Keyword `pub` in union definition." HString.new
            tok::loc
            HayError.new Result.Err::<Opt<UntypedMember> HayError> return
        }

        self Parser.parse_type as [result] {
            &result Result.is_ok if {
                result Result.unwrap
            } else {
                result Result.unwrap_err Result.Err::<Opt<UntypedMember> HayError> return 
            }
        } as [maybe_type] {
            &maybe_type Opt.is_some if {
                maybe_type Opt.unwrap
            } else {
                vis Visibility::Public == if {
                    self Parser.peek as [peek]
                    vis_tok Opt.unwrap as [tok]
                    "Expected a type after " HString.new
                    Keyword::Pub             Keyword.format
                    ", but found "           HString.push_str
                    peek::kind               TokenKind.format
                    " instead."              HString.push_str
                    tok::loc
                    HayError.new Result.Err::<Opt<UntypedMember> HayError> return
                } else {
                    Opt.None::<UntypedMember> Result.Ok::<Opt<UntypedMember> HayError> return
                }
            }
        } as [token]

        Marker::Colon TokenKind.Marker self Parser.matches as [result] {
            &result Result.is_err if {
                result Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::Colon Marker.format
                " after type, but found " HString.push_str
                &t::kind TokenKind.format
                " instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Opt<UntypedMember> HayError> return
            }
        }

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap 
            } else {
                match Result.unwrap_err as [t]
                "Expected an identifier, but found " HString.new
                &t::kind TokenKind.format
                t::loc
                HayError.new Result.Err::<Opt<UntypedMember> HayError> return
            }
        } as [ident]

        type Token.clone
        kind @ RecordKind::Union == if {
            Visibility::Public
        } else {
            vis
        }
        token
        ident
        cast(UntypedMember) Opt.Some Result.Ok::<Opt<UntypedMember> HayError>

    }

    fn Parser.members(
        &Token: start_tok 
        &Token: type_tok 
        &RecordKind: kind 
        *Parser: self
    ) -> [Result<Vec<UntypedMember> HayError>] {
        Vec.new::<UntypedMember> as [mut members]
        while type_tok kind self Parser.member as [result] {
            
            &result Result.is_err if {
                result Result.unwrap_err Result.Err::<Vec<UntypedMember> HayError> return
            } else {
                result Result.unwrap as [member]
                member
                &member Opt.is_some
            }
        }
        {
            Opt.unwrap *members Vec.push
        } drop

        *members Vec.is_empty if {
            "Record members canot be empty." HString.new
            start_tok::loc @
            HayError.new Result.Err::<Vec<UntypedMember> HayError>
        } else {
            members Result.Ok::<Vec<UntypedMember> HayError>
        }
    }

    fn Parser.impl_section(&Token: impl_on *Parser: self) -> [Result<Opt<Vec<Stmt>> HayError>]
    {

        Keyword::Impl TokenKind.Keyword self Parser.matches Result.take_is_ok if {
            
            Marker::Colon TokenKind.Marker self Parser.matches as [match] {
                &match Result.is_err if {
                    match Result.unwrap_err as [t]
                    "Expected "   HString.new
                    Marker::Colon Marker.format
                    " after "     HString.push_str
                    Keyword::Impl Keyword.format 
                    ", but found" HString.push_str
                    &t::kind      TokenKind.format
                    " instead."    HString.push_str
                    t::loc
                    HayError.new Result.Err::<Opt<Vec<Stmt>> HayError> return 
                }
            }

            Vec.new::<Stmt> as [mut fns]

            true while {

                Keyword::Function TokenKind.Keyword self Parser.matches dup Result.take_is_ok if {
                    Result.unwrap Vec.new::<FnTag> impl_on Opt.Some self Parser.function as [result]
                    &result Result.is_ok if {
                        result Result.unwrap as [mut stmts] 
                        *stmts *fns Vec.append
                        &stmts Vec.delete
                    } else {
                        result Result.unwrap_err Result.Err::<Opt<Vec<Stmt>> HayError> return
                    }
                    true
                } else drop Keyword::Inline TokenKind.Keyword self Parser.matches dup Result.take_is_ok if {
                    Result.unwrap impl_on Opt.Some self Parser.inline_function as [result]
                    &result Result.is_ok if {
                        result Result.unwrap as [mut stmts] 
                        *stmts *fns Vec.append
                        &stmts Vec.delete
                    } else {
                        result Result.unwrap_err Result.Err::<Opt<Vec<Stmt>> HayError> return
                    }
                    true
                } else {
                    drop
                    false
                }
                
            }

            fns Opt.Some Result.Ok::<Opt<Vec<Stmt>> HayError>

        } else {
            Opt.None::<Vec<Stmt>> Result.Ok::<Opt<Vec<Stmt>> HayError>
        }

    }

    fn Parser.record(Token: start *Parser: self) -> [Result<Vec<Stmt> HayError>] {
        &start Token.keyword as [r] {
            &r Result.is_err if {
                r Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
            } else {
                r Result.unwrap 
            }
        } as [kw]

        kw Keyword::Union == if {
            RecordKind::Union
        } else {
            RecordKind::Struct
        } as [kind]

        TokenKind.ident_default self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap
            } else {
                match Result.unwrap_err as [t]
                "Expected an identifier after " HString.new
                kw                              Keyword.format
                ", but found"                   HString.push_str
                &t::kind                        TokenKind.format
                " instead"                      HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return 
            }
        } as [name]

        Operator.LessThan TokenKind.Operator self Parser.matches as [match] {
            &match Result.is_ok if {
                match Result.unwrap as [annotation_start]
                &annotation_start self Parser.unnamed_args_list as [result] {
                    &result Result.is_ok if {
                        result Result.unwrap
                    } else {
                        result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
                    }
                }
                Opt.Some

                Operator.GreaterThan TokenKind.Operator self Parser.matches as [ann_end_match]
                &ann_end_match Result.is_err if {
                    drop ann_end_match Result.unwrap_err as [t]
                    "Expected " HString.new
                    Operator.GreaterThan Operator.take_format
                    " after " HString.push_str
                    kw Keyword.format
                    " generics, but found " HString.push_str
                    &t::kind TokenKind.format
                    " instead." HString.push_str
                    t::loc
                    HayError.new Result.Err::<Vec<Stmt> HayError> return
                }

            } else {
                Opt.None::<Vec<UntypedArg>>
            }
        } as [annotations]

        Marker::Colon TokenKind.Marker self Parser.matches Result.take_is_ok if {
            Vec.new::<Stmt> as [mut stmts]
            start name kind annotations 
            cast(PreDeclarationStmt) Stmt.PreDeclaration *stmts Vec.push
            stmts Result.Ok::<Vec<Stmt> HayError> return
        }

        Marker::LeftBrace TokenKind.Marker self Parser.matches as [match]{
        &match Result.is_err if {
            match Result.unwrap_err as [t]
            "Expected "         HString.new
            Marker::LeftBrace   Marker.format
            " after "           HString.push_str
            kind                RecordKind.format
            " name, but found " HString.push_str
            &t::kind            TokenKind.format
            " instead."         HString.push_str
            t::loc
            HayError.new Result.Err::<Vec<Stmt> HayError> return
        }}

        &start &name &kind self Parser.members as [result] {
            &result Result.is_err if {
                result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
            } else {
                result Result.unwrap
            }
        } as [members]

        &name self Parser.impl_section as [result] {
            &result Result.is_err if {
                result Result.unwrap_err Result.Err::<Vec<Stmt> HayError> return
            } else {
                result Result.unwrap
            }
        } as [impls]

        Marker::RightBrace TokenKind.Marker self Parser.matches as [result] {
            &result Result.is_err if {
                result Result.unwrap_err as [t]
                "Expected " HString.new
                Marker::RightBrace Marker.format
                " to close " HString.push_str
                kind RecordKind.format
                ", but found " HString.push_str
                &t::kind TokenKind.format
                "instead." HString.push_str
                t::loc
                HayError.new Result.Err::<Vec<Stmt> HayError> return
            }
        }

        Vec.new::<Stmt> as [mut stmts]
        start
        name
        annotations
        members
        kind
        cast(RecordStmt) Stmt.Record *stmts Vec.push

        &impls Opt.is_some if {
            impls Opt.unwrap as [mut impl_fns]
            *impl_fns *stmts Vec.append
            &impl_fns Vec.delete 
        }

        stmts Result.Ok::<Vec<Stmt> HayError> 

    }
}